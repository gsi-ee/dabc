/* Generated by Together */

#include "DABCDimServer.h"
#include "DABCRegistry.h"


///////////////////////////////////////////////////////////////////
//// DimServiceEntry
///////////////////////////////////////////////////////////////////

dabc::xd::DimServer* dabc::xd::DimServer::theInstance_=0;
#if __XDAQVERSION__  > 310      
toolbox::BSem* dabc::xd::DimServer::globalMutex_=new toolbox::BSem(toolbox::BSem::FULL, true);
#else
BSem* dabc::xd::DimServer::globalMutex_=new BSem(BSem::FULL, true);
#endif


dabc::xd::DimServer::DimServer()
{
#if __XDAQVERSION__  > 310      
appMutex_=new toolbox::BSem(toolbox::BSem::FULL,true); // recursive mutex
#else   
appMutex_=new BSem(BSem::FULL,true); // recursive mutex
#endif
theApplications_.clear();
applicationListBuffer_=new char[DIMSTRINGBUFSIZE];
applicationListString="";
applicationList_=0;     
DimServer::addClientExitHandler(this); 
DimServer::addExitHandler(this); 
DimServer::addErrorHandler(this);
DimServer::autoStartOff(); // avoid problems with concurrent update/registering before dimserver start 
isStarted_=false;



}	

dabc::xd::DimServer::~DimServer()
{
delete applicationList_;   
delete [] applicationListBuffer_;    
delete appMutex_;
}

dabc::xd::DimServer* dabc::xd::DimServer::Instance()
{
// need static mutex here to avoid double creation of server by access glitch     
LockGuard g(globalMutex_); 
   if(theInstance_==0) 
      theInstance_=new dabc::xd::DimServer();
return theInstance_;   
}
    
void dabc::xd::DimServer::Delete()
{
// need static mutex here to avoid double deletion
LockGuard g(globalMutex_); 
if(theInstance_!=0)
   { 
      delete theInstance_;
      theInstance_=0;
   }
}

void dabc::xd::DimServer::Start(std::string name, std::string dnsnode, unsigned int dnsport)
{
if(isStarted_) return;
if(dnsport!=0) DimServer::setDnsNode ( dnsnode.c_str(), dnsport);
//std::cout <<"starting DIM server of name "<<name << std::endl;
//std::cout <<"dns: node="<<dnsnode<<", port="<<dnsport << std::endl;
DimServer::autoStartOn(); // any new service will be started afterwards   
DimServer::start(name.c_str());
// now create service for list of applications:
StartApplicationListService(name); 
isStarted_=true;
   
} 
    
void dabc::xd::DimServer::StartApplicationListService(std::string& name)
{
if(applicationList_)
{
   delete applicationList_;
}
std::string applistname=name+"/applicationList";
std::cout <<"-----StartApplicationListService for "<<applistname << std::endl;
applicationList_=new ::DimService(applistname.c_str(),applicationListBuffer_);

}


void dabc::xd::DimServer::Stop()
{
if(isStarted_)
   {   
   ::DimServer::stop();      
   isStarted_=false;
   }
}




    
void dabc::xd::DimServer::RegisterApplication(dabc::xd::Registry* app)
{
   if(app==0) return; // warning here?
LockGuard g(appMutex_);    
      theApplications_.push_back(app);
      // here we take application names and id numbers:
      std::string uan=app->GetUniqueApplicationName();
      applicationListString+=uan+"|";
      strncpy(applicationListBuffer_, applicationListString.c_str(),DIMSTRINGBUFSIZE);      
}
     
void dabc::xd::DimServer::UnRegisterApplication(dabc::xd::Registry* app)
{
if(app==0) return; // warning here?
LockGuard g(appMutex_); 
std::vector<dabc::xd::Registry*>::iterator iter;
std::vector<dabc::xd::Registry*>::iterator toRemove;
for(iter=theApplications_.begin(); iter!=theApplications_.end(); ++iter)
	{
		
      dabc::xd::Registry* cursor=*iter;
      if(cursor==app)
         {
            toRemove=iter;
            std::cout <<"found application to unregister "<<app << std::endl;
            break;  
         }
	}// for   
theApplications_.erase(toRemove);
std::string uan=app->GetUniqueApplicationName()+"|";
applicationListString.replace(applicationListString.find(uan),uan.length(),"");
strncpy(applicationListBuffer_, applicationListString.c_str(),DIMSTRINGBUFSIZE);      
   
}


void dabc::xd::DimServer::commandHandler()
{ 
LockGuard g(appMutex_); 
   ::DimCommand* com = getCommand();
   if(com==0)
      { 
         std::cout <<"NEVER COME HERE: dabc::DimServer::commandHandler() zero command" << std::endl;
         return;
      }
   //std::cout << "Client " << getClientName() << " has send command "<<com->getName()  << std::endl;
   std::string comname=com->getName();
   std::vector<dabc::xd::Registry*>::const_iterator iter;
   for(iter=theApplications_.begin(); iter!=theApplications_.end(); ++iter)
	{
      dabc::xd::Registry* cursor=*iter;
      std::string appname=cursor->GetUniqueApplicationName();
      if(comname.find(appname)!=std::string::npos)
         {
            //std::cout << "handling command in application "<<appname  << std::endl;
            cursor->HandleDIMCommand(com);
            break;  
         }
	}// for   
} 

void dabc::xd::DimServer::errorHandler(int severity, int code, char *msg)
{
LockGuard g(appMutex_); 
//   std::cout << "dabc::DimServer errorHandler for severity:"<<severity<<", code:"<<code << std::endl;
//   std::cout << "message: "<<msg << std::endl;
 // here we send error messages to all registered applications...
 std::vector<dabc::xd::Registry*>::const_iterator iter;
 for(iter=theApplications_.begin(); iter!=theApplications_.end(); ++iter)
	{
      dabc::xd::Registry* cursor=*iter;
      cursor->OnErrorDIMServer(severity, code, msg); 
	}// for      
} 



void dabc::xd::DimServer::clientExitHandler() 
{
LockGuard g(appMutex_); 
   //std::cout << "Client " << getClientName() << " did exit" << std::std::endl;
   std::vector<dabc::xd::Registry*>::const_iterator iter;
   for(iter=theApplications_.begin(); iter!=theApplications_.end(); ++iter)
	{
      dabc::xd::Registry* cursor=*iter;
      cursor->OnExitDIMClient(getClientName()); // forward to all applications
	}// for     
} 

void dabc::xd::DimServer::exitHandler( int code ) 
{
LockGuard g(appMutex_); 
   //std::cout << "Client  sends exit with code "<<code << std::endl;
   std::vector<dabc::xd::Registry*>::const_iterator iter;
   for(iter=theApplications_.begin(); iter!=theApplications_.end(); ++iter)
	{
      dabc::xd::Registry* cursor=*iter;
      cursor->OnExitDIMServer(code); // forward to all applications
	}// for       
} 

////////////////////////////////////////////////////////////////////
//// DimServiceEntry
///////////////////////////////////////////////////////////////////



#if __XDAQVERSION__  > 310      

/** class to keep dim services together with xdaq process variable
 important for strings, since dim needs resident char* buffer for this */
dabc::xd::DimServiceEntry::DimServiceEntry(xdata::Serializable *variable, std::string dimname, toolbox::BSem* mutex)
  : dimservice_(0),stringbuffer_(0),xdata_(variable), parser_(dimname.c_str()),servMutex_(mutex) //quality_(0) 
#else   
dabc::xd::DimServiceEntry::DimServiceEntry(xdata::Serializable *variable, std::string dimname)
  : dimservice_(0),stringbuffer_(0),xdata_(variable), parser_(dimname.c_str()) //quality_(0) 
#endif

{
   //std::cout <<"--------- Ctor of DimServiceEntry for "<<dimname << std::endl;

   InitService(variable,dimname);   
} 
        
dabc::xd::DimServiceEntry::~DimServiceEntry()
{
 delete dimservice_;
 delete [] stringbuffer_;
}
        
const char* dabc::xd::DimServiceEntry::getDimName()
{
   if(dimservice_) return dimservice_->getName();
   return 0;  
}        


void dabc::xd::DimServiceEntry::InitService(xdata::Serializable *variable, std::string dimname)
{
   //std::cout <<"++DimServiceEntry::InitService for "<<dimname<<", variable="<<(int*) variable << std::endl;  
   xdata::String* serString=dynamic_cast<xdata::String*>(variable);
   xdata::Float* serFloat=dynamic_cast<xdata::Float*>(variable);
   xdata::Double* serDouble=dynamic_cast<xdata::Double*>(variable);
   xdata::Integer* serInteger=dynamic_cast<xdata::Integer*>(variable);
   xdata::UnsignedInteger* serUInt=dynamic_cast<xdata::UnsignedInteger*>(variable);
   xdata::UnsignedLong* serULong=dynamic_cast<xdata::UnsignedLong*>(variable);
   xdata::UnsignedShort* serUShort=dynamic_cast<xdata::UnsignedShort*>(variable);
   xdata::Boolean* serBool=dynamic_cast<xdata::Boolean*>(variable);  
   xdata::Bag<dabc::xd::RateRecord>* serRate=dynamic_cast<xdata::Bag<dabc::xd::RateRecord> *>(variable);
   xdata::Bag<dabc::xd::StatusRecord>* serState=dynamic_cast<xdata::Bag<dabc::xd::StatusRecord> *>(variable);
   xdata::Bag<dabc::xd::InfoRecord>* serInfo=dynamic_cast<xdata::Bag<dabc::xd::InfoRecord> *>(variable);
   xdata::Bag<dabc::xd::HistogramRecord>* serHis=dynamic_cast<xdata::Bag<dabc::xd::HistogramRecord> *>(variable);
 
   
    
   if(serString)
      {
          // need to keep string content in char array
          dimservice_=new DimService (dimname.c_str(), (char*) serString->value_.c_str());//serString->toString().c_str()) ;
          //std::cout <<"added dim string service for " <<dimname << std::endl;
          SetType(dabc::xd::nameParser::ATOMIC);
          UpdateBuffer(variable,true);
      }
   else if(serFloat)
       {
         dimservice_=new DimService (dimname.c_str(), serFloat->value_) ;
         SetType(dabc::xd::nameParser::ATOMIC);
         //std::cout <<"added dim float service for " <<dimname << std::endl;
       }
   else if(serDouble)
       {
          dimservice_=new DimService (dimname.c_str(), serDouble->value_) ;
          SetType(dabc::xd::nameParser::ATOMIC);
          //std::cout <<"added dim double service for double " <<dimname << std::endl;
       }
   else if(serInteger)
       {
          dimservice_=new DimService (dimname.c_str(), serInteger->value_) ;
          SetType(dabc::xd::nameParser::ATOMIC);
          //std::cout <<"added dim int service for " <<dimname << std::endl;
       }
   else if(serUInt)
       {
          dimservice_=new DimService (dimname.c_str(), (int&) serUInt->value_) ;
          SetType(dabc::xd::nameParser::ATOMIC);
          //std::cout <<"added dim int service for " <<dimname << std::endl;
       }    
   else if(serULong)
       {
#ifdef x86_64
		  dimservice_=new DimService (dimname.c_str(), (long&) serULong->value_) ;
#else
          dimservice_=new DimService (dimname.c_str(), (long long&)serULong->value_) ;
#endif
           SetType(dabc::xd::nameParser::ATOMIC);
          //std::cout <<"added dim long long service for " <<dimname << std::endl;
       } 
   else if(serUShort)
       {
          dimservice_=new DimService (dimname.c_str(), (short&) serUShort->value_) ;
           SetType(dabc::xd::nameParser::ATOMIC);
          //std::cout <<"added dim short service for " <<dimname << std::endl;
       }         
    else if(serBool)
       {
          dimservice_=new DimService (dimname.c_str(), (int&) serBool->value_) ;
          SetType(dabc::xd::nameParser::ATOMIC);
          //std::cout <<"added dim bool service for " <<dimname << std::endl;
       }
     else if(serRate) 
      {
         dabc::RateRec rec; // note: this is dummy for creation of service!
         int recsize=sizeof(dabc::RateRec);
         dimservice_=new DimService (dimname.c_str(),const_cast<char*>(dabc::RateRecDesc)  ,&rec,recsize);
         SetType(dabc::xd::nameParser::RATE);
         UpdateBuffer(variable,true);
      } 
    else if(serState) 
      {
        
         dabc::StatusRec rec; // note: this is dummy for creation of service!
         int recsize=sizeof(dabc::StatusRec);
         dimservice_=new DimService (dimname.c_str(),const_cast<char*>(dabc::StatusRecDesc)  ,&rec,recsize);
         SetType(dabc::xd::nameParser::STATUS);
         UpdateBuffer(variable,true);
      }
    else if(serInfo) 
      {
         dabc::InfoRec rec; // note: this is dummy for creation of service!
         int recsize=sizeof(dabc::InfoRec);
         dimservice_=new DimService (dimname.c_str(),const_cast<char*>(dabc::InfoRecDesc)  ,&rec,recsize);
         SetType(dabc::xd::nameParser::INFO);
         UpdateBuffer(variable,true);
      }    
    else if(serHis) 
      {         
         dabc::HistogramRec rec; // note: this is dummy for creation of service!
         int recsize=sizeof(dabc::HistogramRec);
         dimservice_=new DimService (dimname.c_str(),const_cast<char*>(dabc::HistogramRecDesc)  ,&rec,recsize);
         SetType(dabc::xd::nameParser::HISTOGRAM);
         UpdateBuffer(variable,true);
      } 
    else
      {
         std::cout <<toolbox::toString("dabc::xd::DimServiceEntry::InitService has unknown type for DIM:%s",variable->type().c_str())<<std::endl;    
      //std::cout <<"unknown dim type for "<<dimna << std::endl;  
      }
   
   
} 
      


        
void dabc::xd::DimServiceEntry::UpdateBuffer(xdata::Serializable *variable, bool initialize)
{
   //std::cout <<"++DimServiceEntry::UpdateBuffer , init="<< initialize<<" for "<< (int*) variable << std::endl;  
  xdata::String* serString=dynamic_cast<xdata::String*>(variable);
  xdata::Bag<dabc::xd::RateRecord>* serRate=dynamic_cast<xdata::Bag<dabc::xd::RateRecord> *>(variable);
  xdata::Bag<dabc::xd::StatusRecord>* serState=dynamic_cast<xdata::Bag<dabc::xd::StatusRecord> *>(variable);
  xdata::Bag<dabc::xd::InfoRecord>* serInfo=dynamic_cast<xdata::Bag<dabc::xd::InfoRecord> *>(variable);
  xdata::Bag<dabc::xd::HistogramRecord>* serHis=dynamic_cast<xdata::Bag<dabc::xd::HistogramRecord> *>(variable);
  if(serString)      
   {
       if(stringbuffer_==0) stringbuffer_=new char[DIMSTRINGBUFSIZE];
       strncpy(stringbuffer_, serString->toString().c_str(),DIMSTRINGBUFSIZE);
       if(initialize)  dimservice_->updateService(stringbuffer_);   
   }
  else if (serRate)
   {
       int recsize=sizeof(dabc::RateRec);
       if(stringbuffer_==0) stringbuffer_=new char[recsize];
       dabc::RateRec* rec= (dabc::RateRec*) (stringbuffer_);       
       rec->value=(float) serRate->bag.rate_;
       rec->displaymode= (int) serRate->bag.displayMode_;
       rec->lower= (float) serRate->bag.loLimit_;
       rec->upper= (float) serRate->bag.upLimit_;
       rec->alarmlower= (float) serRate->bag.loAlarm_;
       rec->alarmupper= (float) serRate->bag.upAlarm_;
       strncpy(rec->color, serRate->bag.color_.toString().c_str(),sizeof(rec->color));
       strncpy(rec->alarmcolor, serRate->bag.colorAlarm_.toString().c_str(),sizeof(rec->alarmcolor));
       strncpy(rec->units, serRate->bag.units_.toString().c_str(),sizeof(rec->units));
       if(initialize)  dimservice_->updateService((void*) stringbuffer_, recsize);  
   } 
 else if (serState)
   {
       int recsize=sizeof(dabc::StatusRec);
       if(stringbuffer_==0) stringbuffer_=new char[recsize];
       dabc::StatusRec* rec= (dabc::StatusRec*) (stringbuffer_);   
       rec->severity=(int) serState->bag.severity_;
       strncpy(rec->color, serState->bag.color_.toString().c_str(),sizeof(rec->color));
       strncpy(rec->status, serState->bag.status_.toString().c_str(),sizeof(rec->status));
       if(initialize)  dimservice_->updateService((void*) stringbuffer_, recsize);  
 
   }
 else if (serInfo)
   {
       int recsize=sizeof(dabc::InfoRec);
       if(stringbuffer_==0) stringbuffer_=new char[recsize];
       dabc::InfoRec* rec= (dabc::InfoRec*) (stringbuffer_);   
       rec->verbose=(int) serInfo->bag.verbosity_;
       strncpy(rec->color, serInfo->bag.color_.toString().c_str(),sizeof(rec->color));
       strncpy(rec->info, serInfo->bag.info_.toString().c_str(),sizeof(rec->info));
       if(initialize)  dimservice_->updateService((void*) stringbuffer_, recsize);  
   }  
 else if (serHis)
   {
       int recsize=sizeof(dabc::HistogramRec); 
       recsize += (serHis->bag.channels_  -1) * sizeof(int) ;// add size of data field after header
       if(stringbuffer_==0) stringbuffer_=new char[recsize];
       dabc::HistogramRec* rec= (dabc::HistogramRec*) (stringbuffer_);   
       rec->channels=(int) serHis->bag.channels_;  
       rec->xlow=(float) serHis->bag.xLow_;    
       rec->xhigh=(float) serHis->bag.xHigh_;
       strncpy(rec->xlett, serHis->bag.xLett_.toString().c_str(),sizeof(rec->xlett));
       strncpy(rec->cont, serHis->bag.cont_.toString().c_str(),sizeof(rec->cont));
       strncpy(rec->color, serHis->bag.color_.toString().c_str(),sizeof(rec->color));
       int* currentchannel= (int*) (rec+1) -1; // go back first channel that is part of histogram rec structure
       for(int j=0; j<rec->channels;++j)
         {
             currentchannel[j]= (int) (serHis->bag.data_[j]); 
         }
       if(initialize)  dimservice_->updateService((void*) stringbuffer_, recsize);  
     
   }
}

void dabc::xd::DimServiceEntry::UpdateDIM()
{
   // need to copy string content to dim registered char array
   UpdateBuffer(xdata_);
   //if(dabc::xd::DimServer::Instance()->isStarted())
      dimservice_->updateService();
   //else
     //std::cout <<"/////// DimServiceEntry::UpdateDIM not done for "<<getDimName()<<", server not yet started"<< std::endl;  
       
   // only trigger update after server start complete
}
   
void dabc::xd::DimServiceEntry::SetValue(std::string val)
{
if(parser_.isChangable()) 
   {   
      // this is stupid thing, but stems from xdaq non-consequent usage of templates:
      // would need the data types as non-templated subtypes of xdata::Serializable here!
      // besides, the fromString method is not defined as top level interface :-(
      xdata::String* serString=dynamic_cast<xdata::String*>(xdata_);
      xdata::Float* serFloat=dynamic_cast<xdata::Float*>(xdata_);
      xdata::Double* serDouble=dynamic_cast<xdata::Double*>(xdata_);
      xdata::Integer* serInteger=dynamic_cast<xdata::Integer*>(xdata_);
      xdata::UnsignedInteger* serUInt=dynamic_cast<xdata::UnsignedInteger*>(xdata_);
      xdata::UnsignedLong* serULong=dynamic_cast<xdata::UnsignedLong*>(xdata_);
      xdata::UnsignedShort* serUShort=dynamic_cast<xdata::UnsignedShort*>(xdata_);
      xdata::Boolean* serBool=dynamic_cast<xdata::Boolean*>(xdata_);
      if(serString)
         {
            serString->fromString(val);
         }
      else if(serFloat)
         {
            serFloat->fromString(val);
            //dimservice_->updateService(serFloat->value_); // if serializable buffer should have changed? 
         }
      else if(serDouble)
       {
           serDouble->fromString(val);
       }
      else if(serInteger)
          {
             serInteger->fromString(val);
          }
      else if(serUInt)
          {
             serUInt->fromString(val);
          }    
      else if(serULong)
          {
            serULong->fromString(val);
          } 
      else if(serUShort)
          {
             serFloat->fromString(val);
          }         
       else if(serBool)
          {
             serBool->fromString(val);  
          }     
      std::cout <<"%%%%%%%%%%%%%%%%% "<<getDimName()<<" changes to "<< val<< std::endl;
      UpdateDIM();
   }   
else
   {
      std::cout <<"%%%%%%%%%%%%%%%%% "<<getDimName()<<" tried to change to "<< val<<", but not allowed" << std::endl;
   }
}              


void dabc::xd::DimServiceEntry::SetType(dabc::xd::nameParser::recordtype t)
{   
 parser_.setType(t); 
 if(dimservice_) 
   dimservice_->setQuality(parser_.getQuality());

   
}



dabc::xd::nameParser::recordtype dabc::xd::DimServiceEntry::GetType()
{
return (parser_.getType());   
}
                
void dabc::xd::DimServiceEntry::SetVisibility(dabc::xd::nameParser::visiblemask mask)
{
parser_.setVisibility(mask); 
if(dimservice_) 
   dimservice_->setQuality(parser_.getQuality());

   
}
        
dabc::xd::nameParser::visiblemask dabc::xd::DimServiceEntry::GetVisibility()
{
return (parser_.getVisibility());   
}
        
void dabc::xd::DimServiceEntry::SetStatus(dabc::xd::nameParser::recordstat s)
{
parser_.setStatus(s); 
if(dimservice_) 
   dimservice_->setQuality(parser_.getQuality());


   
}
        
dabc::xd::nameParser::recordstat dabc::xd::DimServiceEntry::GetStatus()
{
return (parser_.getStatus());      
}
        
dabc::xd::nameParser::recordmode dabc::xd::DimServiceEntry::GetMode()
{
return (parser_.getMode());      
   
   
}

void dabc::xd::DimServiceEntry::SetMode(dabc::xd::nameParser::recordmode m)
{
parser_.setMode(m); 
if(dimservice_) 
   dimservice_->setQuality(parser_.getQuality());
}


///////////////////////////////////////////////////////////////////
//// DimParameterInfo
///////////////////////////////////////////////////////////////////

void dabc::xd::DimParameterInfo::infoHandler( )
{
    // keep debug part
    time_t time;
    time = getTimestamp();
    std::cout << "DimParameterInfo "<<getName()<<"(type="<<fiType<<") received int=" << getInt() << " Time Stamp=" << ctime(&time) << "Quality="<< getQuality() << std::endl;
    
    // call parameter update depending on service type:
    switch (fiType)
        {
            case INTEGER:
                fxPar->InvokeChange(toolbox::toString("%d",getInt()).c_str());
                break;  
            case FLOAT:
                fxPar->InvokeChange(toolbox::toString("%f",getFloat()).c_str());
                break; 
            case DOUBLE:
                fxPar->InvokeChange(toolbox::toString("%e",getDouble()).c_str());
                break; 
            case SHORT: 
                fxPar->InvokeChange(toolbox::toString("%d",getShort()).c_str());
                break;
            case LONGLONG:
                 fxPar->InvokeChange(toolbox::toString("%ld",getLonglong()).c_str());
                break;  
            case STRING:
                fxPar->InvokeChange(getString());
                break; 
            case STRUCTURE:
                fxPar->InvokeChange((char*) getData()); // need method which also uses getSize
                break;
            case NONE:
            default: 
                std::cout <<"Never come here: DimParameterInfo  with no type="<<fiType << std::endl;   
                break;
        };

} 



/* Generated by Together */

#include "DABCApplication.h"
#include "DABCRegistry.h"

#include "xdaq/ApplicationGroup.h"
#include "xdaq/ApplicationStub.h"
#include "xdaq/ApplicationContext.h"
#include "xdaq/ApplicationRegistry.h"

#include "dabc/logging.h"
// use dabc core exceptions

// this is only needed here for fsm definition strings:
#include "dabc/Manager.h"

#include "nameParser.h"

#include "cgicc/CgiDefs.h"
#include "cgicc/Cgicc.h"
#include "cgicc/HTTPHTMLHeader.h"
#include "cgicc/HTMLClasses.h"
#include "xgi/Utils.h"
#include "xgi/Method.h"


//#include "toolbox/Runtime.h"
//#include <exception>
#include <signal.h>

dabc::xd::Application::Application(xdaq::ApplicationStub* stub)
	throw (xdaq::exception::Exception)
   : xdaq::WebApplication(stub), 
      fsm_(toolbox::toString("%s:%d",stub->getDescriptor()->getClassName().c_str(),stub->getDescriptor()->getLocalId())),
      switchedByWSM_(false)
{
   fxRegistry=new dabc::xd::Registry(this);
   dabcVersion_="UNDEFINED";
   std::vector< std::string > infonames=getApplicationContext()->getSharedObjectRegistry()->getObjectNames();
   std::vector<std::string>::const_iterator iter;
   for(iter=infonames.begin(); iter!=infonames.end(); ++iter)
	{
		std::string package=*iter;
      if(package.find(__LIBVERSIONNAMESPACE__)!=std::string::npos)
      {
#if __XDAQVERSION__  > 310    
         config::PackageInfo pinfo=getApplicationContext()->getSharedObjectRegistry()->getPackageInfo(package); 
#else
         toolbox::PackageInfo pinfo=getApplicationContext()->getSharedObjectRegistry()->getPackageInfo(package); 
#endif
         dabcVersion_=pinfo.getName()+" " + pinfo.getLatestVersion() + "("+pinfo.getDate()+"|"+pinfo.getTime()+")";   
         fxVersion=dabcVersion_.toString(); // backup to restore correct version after parameter file load 
         //std::cout <<"Got version from package info:"<<(std::string)(dabcVersion_) << std::endl;
         break;
      }
	}
   

   fsm_.addState ('H', dabc::Manager::stHalted, this, &dabc::xd::Application::AfterStateChangeAction);
   fsm_.addState ('C', dabc::Manager::stConfigured, this, &dabc::xd::Application::AfterStateChangeAction);
   fsm_.addState ('E', dabc::Manager::stReady, this, &dabc::xd::Application::AfterStateChangeAction);
   fsm_.addState ('R', dabc::Manager::stRunning, this, &dabc::xd::Application::AfterStateChangeAction);
   fsm_.addState ('X', dabc::Manager::stError, this, &dabc::xd::Application::AfterStateChangeAction);

   
   fsm_.addStateTransition ('H','C', dabc::Manager::stcmdDoConfigure, this, &dabc::xd::Application::ConfigureAction);
   fsm_.addStateTransition ('C','C', dabc::Manager::stcmdDoConfigure, this, &dabc::xd::Application::NullAction);
 
   fsm_.addStateTransition ('C','E', dabc::Manager::stcmdDoEnable, this, &dabc::xd::Application::EnableAction);
   fsm_.addStateTransition ('E','R', dabc::Manager::stcmdDoStart, this, &dabc::xd::Application::StartAction);
   fsm_.addStateTransition ('R','R', dabc::Manager::stcmdDoStart, this, &dabc::xd::Application::NullAction);
 
   fsm_.addStateTransition ('R','E', dabc::Manager::stcmdDoStop, this, &dabc::xd::Application::StopAction);
   fsm_.addStateTransition ('E','E', dabc::Manager::stcmdDoStop, this, &dabc::xd::Application::NullAction);
   fsm_.addStateTransition ('E','E', dabc::Manager::stcmdDoEnable, this, &dabc::xd::Application::NullAction);
 
   
   fsm_.addStateTransition ('R','H', dabc::Manager::stcmdDoHalt, this, &dabc::xd::Application::HaltAction);
   fsm_.addStateTransition ('E','H', dabc::Manager::stcmdDoHalt, this, &dabc::xd::Application::HaltAction);
   fsm_.addStateTransition ('C','H', dabc::Manager::stcmdDoHalt, this, &dabc::xd::Application::HaltAction);

   fsm_.addStateTransition ('X','H', dabc::Manager::stcmdDoHalt, this, &dabc::xd::Application::HaltAction);
   fsm_.addStateTransition ('F','H', dabc::Manager::stcmdDoHalt, this, &dabc::xd::Application::ResetFailureAction);
   fsm_.addStateTransition ('H','H', dabc::Manager::stcmdDoHalt, this, &dabc::xd::Application::NullAction);
 

   fsm_.addStateTransition ('C','X', dabc::Manager::stcmdDoError, this, &dabc::xd::Application::ErrorAction);
   fsm_.addStateTransition ('E','X', dabc::Manager::stcmdDoError, this, &dabc::xd::Application::ErrorAction);
   fsm_.addStateTransition ('R','X', dabc::Manager::stcmdDoError, this, &dabc::xd::Application::ErrorAction);

 


   fsm_.setFailedStateTransitionAction( this, &dabc::xd::Application::FailureAction );
   fsm_.setFailedStateTransitionChanged(this, &dabc::xd::Application::ChangedToFailure );
   fsm_.setStateName('F', dabc::Manager::stFailure); 
   
   
   fsm_.setInitialState('H');
	fsm_.reset();

   Registry()->DefineSOAPCommand( dabc::Manager::stcmdDoConfigure);
	Registry()->DefineSOAPCommand( dabc::Manager::stcmdDoEnable);
	Registry()->DefineSOAPCommand( dabc::Manager::stcmdDoHalt);
   Registry()->DefineSOAPCommand( dabc::Manager::stcmdDoStart);
   Registry()->DefineSOAPCommand( dabc::Manager::stcmdDoStop);
   Registry()->DefineSOAPCommand( dabc::Manager::stcmdDoError);   
   
   Registry()->DefineSOAPCommand(_DABC_COMMAND_GETINFOSPACE_);
   Registry()->DefineSOAPCommand(_DABC_COMMAND_GETSTATUS_);
	Registry()->DefineSOAPCommand(_DABC_COMMAND_GETTABLE_);
   Registry()->DefineSOAPCommand(_DABC_COMMAND_SETPAR_);
   Registry()->DefineSOAPCommand(_DABC_COMMAND_LOADPARS_);
   Registry()->DefineSOAPCommand(_DABC_COMMAND_SAVEPARS_);
   Registry()->DefineSOAPCommand(_DABC_COMMAND_SHUTDOWN_);
  
	// Bind CGI callbacks
   xgi::bind(this, &dabc::xd::Application::dispatch, "dispatch");

	// Define Web state machine
   wsm_.addState('H', dabc::Manager::stHalted,    this, &dabc::xd::Application::stateMachinePage); // &dabc::xd::Application::stateMachinePage
	wsm_.addState('C', dabc::Manager::stConfigured,     this, &dabc::xd::Application::stateMachinePage);
	wsm_.addState('E', dabc::Manager::stReady,   this, &dabc::xd::Application::stateMachinePage);
	wsm_.addState('R', dabc::Manager::stRunning,   this, &dabc::xd::Application::stateMachinePage);
 	wsm_.addState('F', dabc::Manager::stFailure,   this, &dabc::xd::Application::stateMachinePage);
   wsm_.addState('X', dabc::Manager::stError,   this, &dabc::xd::Application::stateMachinePage);

   wsm_.addStateTransition('H','C', dabc::Manager::stcmdDoConfigure, this, &dabc::xd::Application::Configure, &dabc::xd::Application::failurePage);
	wsm_.addStateTransition('C','E', dabc::Manager::stcmdDoEnable,    this, &dabc::xd::Application::Enable,    &dabc::xd::Application::failurePage);
   wsm_.addStateTransition ('E','R', dabc::Manager::stcmdDoStart, this, &dabc::xd::Application::Start,      &dabc::xd::Application::failurePage);
   wsm_.addStateTransition ('R','E', dabc::Manager::stcmdDoStop, this, &dabc::xd::Application::Stop,      &dabc::xd::Application::failurePage);   
   wsm_.addStateTransition('R','H', dabc::Manager::stcmdDoHalt,      this, &dabc::xd::Application::Halt,      &dabc::xd::Application::failurePage);
	wsm_.addStateTransition('E','H', dabc::Manager::stcmdDoHalt,      this, &dabc::xd::Application::Halt,      &dabc::xd::Application::failurePage);
   wsm_.addStateTransition ('C','H', dabc::Manager::stcmdDoHalt, this, &dabc::xd::Application::Halt,      &dabc::xd::Application::failurePage);
   wsm_.addStateTransition ('X','H', dabc::Manager::stcmdDoHalt, this, &dabc::xd::Application::Halt,      &dabc::xd::Application::failurePage);

   wsm_.addStateTransition('R','X', dabc::Manager::stcmdDoError,      this, &dabc::xd::Application::Halt,      &dabc::xd::Application::failurePage);
	wsm_.addStateTransition('E','X', dabc::Manager::stcmdDoError,      this, &dabc::xd::Application::Halt,      &dabc::xd::Application::failurePage);
   wsm_.addStateTransition ('C','X', dabc::Manager::stcmdDoError, this, &dabc::xd::Application::Halt,      &dabc::xd::Application::failurePage);
 
   wsm_.addStateTransition ('F','H', dabc::Manager::stcmdDoHalt, this, &dabc::xd::Application::ResetFailure,      &dabc::xd::Application::failurePage);
   
   
   wsm_.setInitialState('H');



   std::string& pre=Registry()->GetDIMPrefix();  
   // setup controls heartbeat thread:
   heartbeatPeriod_=__UPTIMEHEARTBEAT__;
   std::string actionname=pre+"heartbeat";
   std::string loopname=pre+"uptimeloop";
   heartBeatAction_ = toolbox::task::bind (this, &dabc::xd::Application::heartBeat, actionname);  
	heartBeatLoop_ = toolbox::task::getWorkLoopFactory()->getWorkLoop(loopname, "waiting");
	heartBeatLoop_->activate();

   currentState_=fsm_.getStateName(fsm_.getCurrentState());
   theState_=fsm_.getCurrentState();
   Registry()->RegisterSerializable(_DABC_SERVICE_HEARTBEAT_, &heartbeatPeriod_ , true, true);
   Registry()->RegisterSerializable(_DABC_SERVICE_VERSION_, &dabcVersion_ , false, true);
	uptimeClock_.start(0);
   startTime_=(unsigned int) (uptimeClock_.tstamp());
   fuStartTime= (unsigned int) startTime_; // backup value in case of load parameters from file
   Registry()->RegisterSerializable(_DABC_SERVICE_STARTTIME_, &startTime_ , false, true);
   statusMessage_="Initializing...";
   Registry()->RegisterSerializable(_DABC_SERVICE_MESSAGE_, &statusMessage_ , false, true);
   clusterNodes_=CreateContextList(); // list already known at this moment
   fxNodes=clusterNodes_.toString(); //backup to restore correct situation after loading extern paramters file
   // export fsm state for dim:
   Registry()->RegisterSerializable(_DABC_SERVICE_STATE_, &currentState_ , false, true); // need change listener for state

   // export list of nodes (contexts) from cluster configuration:
   Registry()->RegisterSerializable(_DABC_SERVICE_NODELIST_, &clusterNodes_ , false, true);

   Registry()->DefineDIMCommand(dabc::Manager::stcmdDoConfigure);
   Registry()->DefineDIMCommand(dabc::Manager::stcmdDoEnable);
   Registry()->DefineDIMCommand(dabc::Manager::stcmdDoHalt);
   Registry()->DefineDIMCommand(dabc::Manager::stcmdDoStart);
   Registry()->DefineDIMCommand(dabc::Manager::stcmdDoStop);
   Registry()->DefineDIMCommand(dabc::Manager::stcmdDoError);
   
   Registry()->DefineDIMCommand(_DABC_COMMAND_SHUTDOWN_);
   Registry()->DefineDIMCommand(_DABC_COMMAND_SETPAR_);
   Registry()->DefineDIMCommand(_DABC_COMMAND_LOADPARS_);
   Registry()->DefineDIMCommand(_DABC_COMMAND_SAVEPARS_);

   debugLevel_=1;
   Registry()->RegisterSerializable(_DABC_SERVICE_DEBUG_, &debugLevel_ , true);
   dabc::SetDebugLevel(debugLevel_);
   Registry()->AddStatusRecord(_DABC_SERVICE_FSMRECORD_, currentState_.toString(),0,"Red");
   Registry()->AddInfoRecord(_DABC_SERVICE_INFORECORD_,"Created.",1,"Green");

   StartDIMServer(); 
}	


dabc::xd::Application::~Application()
{
delete fxRegistry;
}









void dabc::xd::Application::ChangeState(const std::string& com)
{
switchedByWSM_=false;    
toolbox::Event::Reference e(new toolbox::Event(com, this));
fsm_.fireEvent(e);
}
  
bool dabc::xd::Application::CheckTransitionPossible(const std::string& com)
{
try
   {
   // check if transition is allowed
   std::map<std::string, toolbox::fsm::State, std::less<std::string> > stateChangedTable = fsm_.getTransitions(fsm_.getCurrentState()); 
   if (stateChangedTable.find(com)!=stateChangedTable.end())
      {
         return true;
      }
   else
      {
        std::cout <<"CheckTransitionPossible: No allowed transition from "<<fsm_.getCurrentState()<<" with command "<<com << std::endl;
        return false;
      }

   }
catch(toolbox::fsm::exception::Exception& e)
   {
   std::cout <<"CheckTransitionPossible sees fsm exception "<<e.what() << std::endl;
   return false;
   }

   
   
}
 

void dabc::xd::Application::NullAction(toolbox::Event::Reference e) throw (toolbox::fsm::exception::Exception )
{	
   //this is dummy method that is called whenever state transition
   // is invoked a second time after target state is already reached
}



void dabc::xd::Application::FailureAction (toolbox::Event::Reference e) throw (toolbox::fsm::exception::Exception)
{
  toolbox::fsm::FailedEvent & fe = dynamic_cast<toolbox::fsm::FailedEvent&>(*e);
  StatusMessage(toolbox::toString("State machine Failure on transition from %c: to %c : %s :\n", fe.getFromState(), fe.getToState(), fe.getException().what()),dabc::xd::nameParser::ERR);
try
   {
    DoHandleFailure(e); 
    //StatusMessage(toolbox::toString("Failure is handled.") ,dabc::xd::nameParser::MESSAGE);
   }
catch (dabc::xd::Exception& xe)
   {
      StatusMessage(toolbox::toString("DABC Exception in %s: %s raised in %s:%s", __FUNCTION__ , xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (xdaq::exception::Exception& xe)
   {
      StatusMessage(toolbox::toString("XDAQ exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (toolbox::fsm::exception::Exception& xe)
   {
      //StatusMessage(toolbox::toString("State machine exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str() , xe.message().c_str()),dabc::xd::nameParser::ERR);
      throw; // will be handled by state machine itself
   }      
catch (...)
   {
      StatusMessage(toolbox::toString("Unecpected exception in %s", __FUNCTION__),dabc::xd::nameParser::FATAL);
   }  

  
  
}

void dabc::xd::Application::ChangedToFailure (toolbox::fsm::FiniteStateMachine & fsm) 
  throw (toolbox::fsm::exception::Exception)
{
   std::string sname=fsm.getStateName( fsm.getCurrentState());
   StatusMessage(toolbox::toString("ChangedToFailure, current state: [%s]", sname.c_str() ) , dabc::xd::nameParser::ERR);
   wsm_.setInitialState('F');
   UpdateState(); 
}


void dabc::xd::Application::AfterStateChangeAction (toolbox::fsm::FiniteStateMachine & fsm) 
  throw (toolbox::fsm::exception::Exception)
{
   std::string sname=fsm.getStateName( fsm.getCurrentState());
   StatusMessage(toolbox::toString("State machine reached current state : [%s]", sname.c_str() ) ,dabc::xd::nameParser::MESSAGE);
   if(!switchedByWSM_) wsm_.setInitialState(fsm_.getCurrentState());
   UpdateState(); // for DIM service      
}



void dabc::xd::Application::ConfigureAction(toolbox::Event::Reference e) throw (toolbox::fsm::exception::Exception)
{
try
   {
   //std::cout <<"---------dabc::xd::Application ConfigureAction" << std::endl;
   DoConfigure(e);
   //StatusMessage(toolbox::toString("ConfigureAction has completed.") ,dabc::xd::nameParser::MESSAGE);
   }
catch (dabc::xd::Exception& xe)
   {
      StatusMessage(toolbox::toString("DABC Exception in %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (xdaq::exception::Exception& xe)
   {
      StatusMessage(toolbox::toString("XDAQ exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str() , xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (toolbox::fsm::exception::Exception& xe)
   {
      //StatusMessage(toolbox::toString("State machine exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str() , xe.message().c_str()),dabc::xd::nameParser::ERR);
      throw; // will be handled by state machine itself

   }

 
catch (...)
   {
      StatusMessage(toolbox::toString("Unecpected exception in %s", __FUNCTION__),dabc::xd::nameParser::FATAL);
   }     

   
}
void dabc::xd::Application::EnableAction(toolbox::Event::Reference e) throw (toolbox::fsm::exception::Exception )
{	
try
   {
   //std::cout <<"--------- dabc::xd::Application EnableAction" << std::endl;
   DoEnable(e);
   //StatusMessage(toolbox::toString("EnableAction has completed.") ,dabc::xd::nameParser::MESSAGE);
   }
catch (dabc::xd::Exception& xe)
   {
      StatusMessage(toolbox::toString("DABC Exception in %s: %s raised in %s:%s", __FUNCTION__ , xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (xdaq::exception::Exception& xe)
   {
      StatusMessage(toolbox::toString("XDAQ exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (toolbox::fsm::exception::Exception& xe)
   {
      //StatusMessage(toolbox::toString("State machine exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str() , xe.message().c_str()),dabc::xd::nameParser::ERR);
      throw; // will be handled by state machine itself
   }      
catch (...)
   {
      StatusMessage(toolbox::toString("Unecpected exception in %s", __FUNCTION__),dabc::xd::nameParser::FATAL);
   }    


}
void dabc::xd::Application::HaltAction(toolbox::Event::Reference e) throw (toolbox::fsm::exception::Exception )
{	
try
   {
   //std::cout <<"--------- dabc::xd::Application HaltAction" << std::endl;
   DoHalt(e);
   //StatusMessage(toolbox::toString("HaltAction has completed.") ,dabc::xd::nameParser::MESSAGE);
   }
catch (dabc::xd::Exception& xe)
   {
      StatusMessage(toolbox::toString("DABC Exception in %s: %s raised in %s:%s", __FUNCTION__ , xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (xdaq::exception::Exception& xe)
   {
      StatusMessage(toolbox::toString("XDAQ exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (toolbox::fsm::exception::Exception& xe)
   {
      //StatusMessage(toolbox::toString("State machine exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str() , xe.message().c_str()),dabc::xd::nameParser::ERR);
      throw; // will be handled by state machine itself
   }   
catch (...)
   {
      StatusMessage(toolbox::toString("Unecpected exception in %s", __FUNCTION__),dabc::xd::nameParser::ERR);
   }    
}

void dabc::xd::Application::StopAction(toolbox::Event::Reference e) throw (toolbox::fsm::exception::Exception )
{	
try
   {
   //std::cout <<"--------- dabc::xd::Application SuspendAction" << std::endl;
   DoStop(e);
   //StatusMessage(toolbox::toString("StopAction has completed.") ,dabc::xd::nameParser::MESSAGE);
   }
catch (dabc::xd::Exception& xe)
   {
      StatusMessage(toolbox::toString("DABC Exception in %s: %s raised in %s:%s", __FUNCTION__ , xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (xdaq::exception::Exception& xe)
   {
      StatusMessage(toolbox::toString("XDAQ exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str() , xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (toolbox::fsm::exception::Exception& xe)
   {
      //StatusMessage(toolbox::toString("State machine exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str() , xe.message().c_str()),dabc::xd::nameParser::ERR);
      throw; // will be handled by state machine itself
   }
catch (...)
   {
      StatusMessage(toolbox::toString("Unecpected exception in %s", __FUNCTION__),dabc::xd::nameParser::FATAL);
   }    
}

void dabc::xd::Application::StartAction(toolbox::Event::Reference e) throw (toolbox::fsm::exception::Exception )
{	
try
   {
   //std::cout <<"--------- dabc::Application ResumeAction" << std::endl;
   DoStart(e);
   //StatusMessage(toolbox::toString("StartAction has completed.") ,dabc::xd::nameParser::MESSAGE);
   }
catch (dabc::xd::Exception& xe)
   {
      StatusMessage(toolbox::toString("DABC Exception in %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str() , xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (xdaq::exception::Exception& xe)
   {
      StatusMessage(toolbox::toString("XDAQ exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (toolbox::fsm::exception::Exception& xe)
   {
      //StatusMessage(toolbox::toString("State machine exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str() , xe.message().c_str()),dabc::xd::nameParser::ERR);
      throw; // will be handled by state machine itself
   }
catch (...)
   {
      StatusMessage(toolbox::toString("Unecpected exception in %s", __FUNCTION__),dabc::xd::nameParser::FATAL);
   }    
}


void dabc::xd::Application::ErrorAction(toolbox::Event::Reference e) throw (toolbox::fsm::exception::Exception)
{
try
   {
   //std::cout <<"---------dabc::xd::Application ErrorAction" << std::endl;
   DoError(e);
   //StatusMessage(toolbox::toString("ErrorAction has completed.") ,dabc::xd::nameParser::MESSAGE);
   }
catch (dabc::xd::Exception& xe)
   {
      StatusMessage(toolbox::toString("DABC Exception in %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (xdaq::exception::Exception& xe)
   {
      StatusMessage(toolbox::toString("XDAQ exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str() , xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (toolbox::fsm::exception::Exception& xe)
   {
      //StatusMessage(toolbox::toString("State machine exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str() , xe.message().c_str()),dabc::xd::nameParser::ERR);
      throw; // will be handled by state machine itself

   }
catch (...)
   {
      StatusMessage(toolbox::toString("Unecpected exception in %s", __FUNCTION__),dabc::xd::nameParser::FATAL);
   }     

}


void dabc::xd::Application::ResetFailureAction(toolbox::Event::Reference e) throw (toolbox::fsm::exception::Exception )
{	
try
   {
   //std::cout <<"--------- dabc::xd::Application HaltAction" << std::endl;
   DoResetFailure(e);
   //StatusMessage(toolbox::toString("ResetFailureAction has completed.") ,dabc::xd::nameParser::MESSAGE);
   }
catch (dabc::xd::Exception& xe)
   {
      StatusMessage(toolbox::toString("DABC Exception in %s: %s raised in %s:%s", __FUNCTION__ , xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (xdaq::exception::Exception& xe)
   {
      StatusMessage(toolbox::toString("XDAQ exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (toolbox::fsm::exception::Exception& xe)
   {
      //StatusMessage(toolbox::toString("State machine exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str() , xe.message().c_str()),dabc::xd::nameParser::ERR);
      throw; // will be handled by state machine itself
   }   
catch (...)
   {
      StatusMessage(toolbox::toString("Unecpected exception in %s", __FUNCTION__),dabc::xd::nameParser::ERR);
   }    
}



void dabc::xd::Application::Default(xgi::Input * in, xgi::Output * out ) throw (xgi::exception::Exception)
{
	//header(in,out);
   wsm_.displayPage(out);
   //footer(in,out);
}

void dabc::xd::Application::header(xgi::Input * in, xgi::Output * out ) throw (xgi::exception::Exception)
{
	*out << cgicc::HTMLDoctype(cgicc::HTMLDoctype::eStrict) << std::endl;
	*out << cgicc::html().set("lang", "en").set("dir","ltr") << std::endl;
	std::string caption=Registry()->GetDIMPrefix();
   caption+=" - Default page";
	xgi::Utils::getPageHeader
		(out, 
		caption, 
		getApplicationDescriptor()->getContextDescriptor()->getURL(),
		getApplicationDescriptor()->getURN(),
		"/daq/xgi/images/Application.gif"
		);   
   
}

void dabc::xd::Application::footer(xgi::Input * in, xgi::Output * out ) throw (xgi::exception::Exception)
{
   xgi::Utils::getPageFooter(*out);      
}
 

void dabc::xd::Application::dispatch (xgi::Input * in, xgi::Output * out)  throw (xgi::exception::Exception)
{
	cgicc::Cgicc cgi(in);
    	//const cgicc::CgiEnvironment& env = cgi.getEnvironment();
	cgicc::const_form_iterator stateInputElement = cgi.getElement("StateInput");
	std::string stateInput = (*stateInputElement).getValue();
	switchedByWSM_=true;
   wsm_.fireEvent(stateInput,in,out);
}

void dabc::xd::Application::WaitFSM (char state, unsigned int period)  throw (xgi::exception::Exception)
{
   char fstate=0;
   while((fstate=fsm_.getCurrentState())!=state)
      {
         if(fstate=='F')
            throw xgi::exception::Exception("State machine exception", "State machine is in Failure! Please do ResetFailure.",__FILE__, __LINE__, __FUNCTION__ );
         ::usleep(period);
      } // while   
}


void dabc::xd::Application::Configure(xgi::Input * in ) throw (xgi::exception::Exception)
{
	try 
	{
		toolbox::Event::Reference e(new toolbox::Event(dabc::Manager::stcmdDoConfigure, this));
		fsm_.fireEvent(e); // triggers asynchronous fsm thread!
      WaitFSM('C'); // synchronize with fsm state switch      
	}
	catch (toolbox::fsm::exception::Exception & e)
	{
		std::cout <<"Configure sees fsm exception "<<e.what() << std::endl;
      XCEPT_RETHROW(xgi::exception::Exception, "invalid command", e);
	}
}

void dabc::xd::Application::Enable(xgi::Input * in ) throw (xgi::exception::Exception)
{
	try 
	{
		toolbox::Event::Reference e(new toolbox::Event(dabc::Manager::stcmdDoEnable, this));
		fsm_.fireEvent(e);
      WaitFSM('E'); // synchronize with fsm state switch      
	}
	catch (toolbox::fsm::exception::Exception & e)
	{
		std::cout <<"Enable sees fsm exception "<<e.what() << std::endl;
      XCEPT_RETHROW(xgi::exception::Exception, "invalid command", e);
	}
}
void dabc::xd::Application::Halt(xgi::Input * in ) throw (xgi::exception::Exception)
{
	try 
	{
		toolbox::Event::Reference e(new toolbox::Event(dabc::Manager::stcmdDoHalt, this));
		fsm_.fireEvent(e);
      WaitFSM('H'); // synchronize with fsm state switch      
	}
	catch (toolbox::fsm::exception::Exception & e)
	{
		std::cout <<"Halt sees fsm exception "<<e.what() << std::endl;
      XCEPT_RETHROW(xgi::exception::Exception, "invalid command", e);
	}
}

void dabc::xd::Application::Stop(xgi::Input * in ) throw (xgi::exception::Exception)
{
	try 
	{
		toolbox::Event::Reference e(new toolbox::Event(dabc::Manager::stcmdDoStop , this));
		fsm_.fireEvent(e);
      WaitFSM('E'); // synchronize with fsm state switch      
	}
	catch (toolbox::fsm::exception::Exception & e)
	{
		std::cout <<"Stop sees fsm exception "<<e.what() << std::endl;
      XCEPT_RETHROW(xgi::exception::Exception, "invalid command", e);
	}
}


void dabc::xd::Application::Start(xgi::Input * in ) throw (xgi::exception::Exception)
{
	try 
	{
		toolbox::Event::Reference e(new toolbox::Event(dabc::Manager::stcmdDoStart, this));
		fsm_.fireEvent(e);
      WaitFSM('R'); // synchronize with fsm state switch      
	}
	catch (toolbox::fsm::exception::Exception & e)
	{
		std::cout <<"Start sees fsm exception "<<e.what() << std::endl;
      XCEPT_RETHROW(xgi::exception::Exception, "invalid command", e);
	}
}

void dabc::xd::Application::Error(xgi::Input * in ) throw (xgi::exception::Exception)
{
	try 
	{
		toolbox::Event::Reference e(new toolbox::Event(dabc::Manager::stcmdDoError, this));
		fsm_.fireEvent(e);
      WaitFSM('X'); // synchronize with fsm state switch      
	}
	catch (toolbox::fsm::exception::Exception & e)
	{
		std::cout <<"Error sees fsm exception "<<e.what() << std::endl;
      XCEPT_RETHROW(xgi::exception::Exception, "invalid command", e);
	}
}


void dabc::xd::Application::ResetFailure(xgi::Input * in ) throw (xgi::exception::Exception)
{
	try 
	{
		std::cout <<"wsm ResetFailure called" << std::endl;
      toolbox::Event::Reference e(new toolbox::Event(dabc::Manager::stcmdDoHalt, this));
		fsm_.fireEvent(e);
      WaitFSM('H'); // synchronize with fsm state switch      
   }
	catch (toolbox::fsm::exception::Exception & e)
	{
		std::cout <<"ResetFailure sees fsm exception "<<e.what() << std::endl;
      XCEPT_RETHROW(xgi::exception::Exception, "invalid command", e);
	}
}


void dabc::xd::Application::stateMachinePage( xgi::Output * out ) throw (xgi::exception::Exception)
{

   header(0,out);
	std::string url = "/";
	url += getApplicationDescriptor()->getURN();
	url += "/dispatch";	

	// display FSM
  	std::set<std::string> possibleInputs = wsm_.getInputs(wsm_.getCurrentState());
        std::set<std::string> allInputs = wsm_.getInputs();


        *out << cgicc::h3("Finite State Machine").set("style", "font-family: arial") << std::endl;
        *out << "<table border cellpadding=10 cellspacing=0>" << std::endl;
        *out << "<tr>" << std::endl;
        *out << "<th>" << wsm_.getStateName(wsm_.getCurrentState()) << "</th>" << std::endl;
        *out << "</tr>" << std::endl;
        *out << "<tr>" << std::endl;
       	std::set<std::string>::iterator i;
        for ( i = allInputs.begin(); i != allInputs.end(); i++)
        {
                *out << "<td>"; 
		*out << cgicc::form().set("method","get").set("action", url).set("enctype","multipart/form-data") << std::endl;

                if ( possibleInputs.find(*i) != possibleInputs.end() )
                {
                        *out << cgicc::input().set("type", "submit").set("name", "StateInput").set("value", (*i) );
                }
                else
                {
                       	*out << cgicc::input() .set("type", "submit").set("name", "StateInput").set("value", (*i) ).set("disabled", "true");
                }

                *out << cgicc::form();
                *out << "</td>" << std::endl;
        }

        *out << "</tr>" << std::endl;
        *out << "</table>" << std::endl;
      footer(0,out);

}


void dabc::xd::Application::failurePage(xgi::Output * out, xgi::exception::Exception & e)  throw (xgi::exception::Exception)
{
	*out << cgicc::HTMLDoctype(cgicc::HTMLDoctype::eStrict) << std::endl;
	*out << cgicc::html().set("lang", "en").set("dir","ltr") << std::endl;
	
	std::string caption=Registry()->GetDIMPrefix();
   caption+=" Failure";
   xgi::Utils::getPageHeader
		(out, 
		caption, 
		getApplicationDescriptor()->getContextDescriptor()->getURL(),
		getApplicationDescriptor()->getURN(),
		"/daq/xgi/images/Application.gif"
		);

	*out << cgicc::br() << e.what() << cgicc::br() << std::endl;
	std::string url = "/";
	url += getApplicationDescriptor()->getURN();
	
	*out << cgicc::br() << "<a href=\"" << url << "\">" << "retry" << "</a>" << cgicc::br() << std::endl;

	xgi::Utils::getPageFooter(*out);
}






void dabc::xd::Application::UpdateState()
{
   theState_=fsm_.getCurrentState();
   currentState_=fsm_.getStateName(fsm_.getCurrentState());
   getApplicationInfoSpace()->fireItemValueChanged(_DABC_SERVICE_STATE_, this); // update for dim
   std::string color="Red";
   switch((unsigned short) theState_)
      {
         case 'H': // halted
            color="Red";
            break;
         case 'C': // configured
            color="Yellow";
            break;
            
         case 'R': // running
            color="Green";
            break;

         case 'E': // enabled
            color="Cyan";
            break;
         case 'F': // failure state
            color="Magenta";         
            break;
         case 'X': // error state
            color="Magenta";         
            break;   
         default: // never come here
            color="Blue"; 
            break;
      };   
   Registry()->UpdateStatusRecord(_DABC_SERVICE_FSMRECORD_,currentState_.toString(),0,color);
   
}

void dabc::xd::Application::StatusMessage(std::string message, dabc::xd::nameParser::recordstat priority)
{
//stringstream text;
//text <<"-"<< priority <<"-:"<< message <<ends;
//statusMessage_=text.str();
statusMessage_=message;
fxLastMessage=message;
//std::cout <<"+++++++++++ StatusMessage is called for:"<<(std::string)(statusMessage_) << std::endl;
std::string color="Green";
switch(priority)
   {
      case dabc::xd::nameParser::MESSAGE:
          color="Green";
         LOG4CPLUS_INFO(getApplicationLogger(), message);
         break;   
      case dabc::xd::nameParser::WARNING:
          color="Yellow";
         LOG4CPLUS_WARN(getApplicationLogger(), message);
         break;   
      case dabc::xd::nameParser::ERR:      
      default:
         color="Red";
         LOG4CPLUS_ERROR(getApplicationLogger(), message); 
         break;     
   }
Registry()->UpdateDIMService(_DABC_SERVICE_MESSAGE_, true, priority); 
Registry()->UpdateInfoRecord(_DABC_SERVICE_INFORECORD_,message,1,color);     
}





void dabc::xd::Application::StartHeartbeatService()
{
 Registry()->RegisterSerializable("runningTime",&runningTime_, false, false); 
 UpdateHeartbeat();
 heartBeatLoop_->submit(heartBeatAction_);
 LOG4CPLUS_INFO(getApplicationLogger(),toolbox::toString("dabc::xd::Application started heartbeat service."));

}    
   
void  dabc::xd::Application::UpdateHeartbeat()
{
uptimeClock_.stop(1); // toolbox::Chrono will continue internally   
runningTime_= (unsigned int) (uptimeClock_.dsecs());
Registry()->UpdateDIMService("runningTime");
//Registry()->UpdateDIMService(_DABC_SERVICE_STATE_);
UpdateState(); // also update state record for gui frequently
}

bool dabc::xd::Application::heartBeat(toolbox::task::WorkLoop* wl)
{
//std::cout <<"SSSSSSSSS heartBeat starts..."<< std::endl;
UpdateHeartbeat();
::sleep(heartbeatPeriod_); 
return true; // continue thread loop
} 
  
void dabc::xd::Application::StartDIMServer()
{
 //Registry()->StartDIMServer(nodeDNS_.toString(),portDNS_);
 Registry()->StartDIMServer("",0); // 0 port means: use environment variables for dns
 StartHeartbeatService();
}



int dabc::xd::Application::FindNumberOfNodes(unsigned int xdaqid)
{
int numnodes=0;
#if __XDAQVERSION__  > 36      
xdaq::Zone* zone = getApplicationContext()->getDefaultZone();
#else
xdaq::ApplicationGroup* applicationgroup=getApplicationContext()->getApplicationGroup();
#endif
xdaq::ContextTable* ctable=getApplicationContext()->getContextTable();
std::vector<xdaq::ContextDescriptor*> contexts=ctable->getContextDescriptors();
std::vector<xdaq::ContextDescriptor*>::const_iterator iter;
for(iter=contexts.begin(); iter!=contexts.end(); ++iter)
	{
		xdaq::ContextDescriptor* dcontext=*iter;
		try
			{
                #if __XDAQVERSION__  > 36 
                //xdaq::ApplicationDescriptor * d =
                zone->getApplicationDescriptor(dcontext, xdaqid);
                #else
                //xdaq::ApplicationDescriptor * d =
                applicationgroup->getApplicationDescriptor(dcontext, xdaqid);
                #endif
                numnodes++; 
         }
		catch(xdaq::exception::Exception& e)
			{
            // id was not found on that node
            continue;
			}
	}// for
//std::cout <<"FindNumberOfNodes has "<< numnodes <<" of tid "<<xdaqid << std::endl;   
return numnodes;
}



xdaq::ApplicationDescriptor * dabc::xd::Application::FindApplication(unsigned int xdaqid, unsigned int instance)
{
xdaq::ApplicationDescriptor * result=0;   
#if __XDAQVERSION__  > 36      
xdaq::Zone* zone = getApplicationContext()->getDefaultZone();
#else
xdaq::ApplicationGroup* applicationgroup=getApplicationContext()->getApplicationGroup();
#endif
xdaq::ContextTable* ctable=getApplicationContext()->getContextTable();
std::vector<xdaq::ContextDescriptor*> contexts=ctable->getContextDescriptors();
std::vector<xdaq::ContextDescriptor*>::const_iterator iter;
for(iter=contexts.begin(); iter!=contexts.end(); ++iter)
	{
		xdaq::ContextDescriptor* dcontext=*iter;
		try
			{
                #if __XDAQVERSION__  > 36 
                xdaq::ApplicationDescriptor * d = zone->getApplicationDescriptor(dcontext, xdaqid);
                #else
                xdaq::ApplicationDescriptor * d = applicationgroup->getApplicationDescriptor(dcontext, xdaqid);
                #endif
                // need instance number for ordering:
                unsigned long apinstance=d->getInstance();
                if(apinstance==instance)
                  { 
                     result=d;
                     break;
                  }
                
         }
		catch(xdaq::exception::Exception& e)
			{
            // id was not found on that node
            continue;
			}
	}// for
//std::cout <<"FindApplication has descriptor "<<result<<" for id="<<xdaqid<<", instance="<<instance << std::endl;
return result;
}   
  


int dabc::xd::Application::FindInstanceID(unsigned int xdaqid, const std::string& contextname)
{
int result=-1;
try
   {
      xdaq::ApplicationDescriptor * d=0;   
      xdaq::ContextTable* ctable=getApplicationContext()->getContextTable();  
      xdaq::ContextDescriptor* cd = ctable->getContextDescriptor(contextname);   
#if __XDAQVERSION__  > 36 
       xdaq::Zone* zone = getApplicationContext()->getDefaultZone();
       d = zone->getApplicationDescriptor(cd, xdaqid);
#else
      xdaq::ApplicationGroup* applicationgroup=getApplicationContext()->getApplicationGroup();
       d = applicationgroup->getApplicationDescriptor(cd, xdaqid);
#endif
       result=d->getInstance();

   }
catch(xdaq::exception::Exception& e)
   {
      	//LOG4CPLUS_WARN(getApplicationLogger(), toolbox::toString("Failed to find instance id in context %s with exception: %s \n",contextname.c_str(), e.what()));
   }
return result;

}








std::string dabc::xd::Application::FindContextName(unsigned int xdaqid, unsigned int instance)
{
std::string result="";   
xdaq::ApplicationDescriptor * ad=0;   
#if __XDAQVERSION__  > 36      
xdaq::Zone* zone = getApplicationContext()->getDefaultZone();
#else
xdaq::ApplicationGroup* applicationgroup=getApplicationContext()->getApplicationGroup();
#endif
xdaq::ContextTable* ctable=getApplicationContext()->getContextTable();
std::vector<xdaq::ContextDescriptor*> contexts=ctable->getContextDescriptors();
std::vector<xdaq::ContextDescriptor*>::const_iterator iter;
for(iter=contexts.begin(); iter!=contexts.end(); ++iter)
	{
		xdaq::ContextDescriptor* dcontext=*iter;
		try
			{
                #if __XDAQVERSION__  > 36 
                ad=zone->getApplicationDescriptor(dcontext, xdaqid);
                #else
                ad=applicationgroup->getApplicationDescriptor(dcontext, xdaqid);
                #endif
                if(ad->getInstance()==instance)
                  {
                      // find ip (hostname) of our context:
                      result=dcontext->getURL();
                      std::string::size_type start=result.find("http://");
                      std::string::size_type end=start+7; // length of http prefix string 
                      if(start!=std::string::npos) // only replace http:// if it was found
                           result.replace(start, end,""); // remove http prefix
                  }
          }
		catch(xdaq::exception::Exception& e)
			{
            // id was not found on that node
            continue;
			}
	}// for
//std::cout <<"FindContextName results:"<< result <<": for tid="<<xdaqid <<", inst="<<instance << std::endl;   
return result;
}


std::string dabc::xd::Application::CreateContextList()
{
std::string list;   
xdaq::ContextTable* ctable=getApplicationContext()->getContextTable();
std::vector<xdaq::ContextDescriptor*> contexts=ctable->getContextDescriptors();
std::vector<xdaq::ContextDescriptor*>::const_iterator iter;
bool firstentry=true;
for(iter=contexts.begin(); iter!=contexts.end(); ++iter)
	{
		xdaq::ContextDescriptor* dcontext=*iter;
		try
			{   
                std::string url=dcontext->getURL();
                std::string::size_type start=url.find("http://");
                std::string::size_type end=start+7; // length of http prefix string 
                if(start!=std::string::npos) // only replace http:// if it was found
                     url.replace(start, end,"");
                //std::cout <<"CreateContextList finds "<<url <<std::endl;
                if(!firstentry) list+=",";
                list+=url;
                firstentry=false;
         }
		catch(xdaq::exception::Exception& e)
			{
				LOG4CPLUS_WARN(getApplicationLogger(), toolbox::toString("dabc::xd::Registry::CreateContextList failed at node %s: %s in (%s:%s):%s",dcontext->getURL().c_str() ,e.name().c_str(),e.module().c_str(),e.function().c_str(),e.what()));
				continue;
			}   
	}
return list;   

}



void dabc::xd::Application::Shutdown()
{
std::string classname=getApplicationDescriptor()->getClassName();   
//std::cout <<"dabc::xd::Application::Shutdown for class "<<classname << std::endl;   
StatusMessage(toolbox::toString("Application %s is shut down, good bye!", classname.c_str()) ,dabc::xd::nameParser::WARNING);
// we test different possibilities, since exit() not always works:
/////////////////////////////
//std::cout <<"Shutdown is exiting with exception..." << std::endl;
//throw (xdaq::exception::Exception( "Terminating","try to terminate via exception", __FILE__, __LINE__, __FUNCTION__ ));
//// <-this works both on Suse10 and Debian3.0 (xdaq 3.14)
     std::cout <<"PerformShutdown exiting with kill(0,9)..." << std::endl;
     ::kill(0,9); // works on Suse10


//
//     std::cout <<"PerformShutdown exiting with exit..." << std::endl;
//     exit(0);  // works on Suse10, but hangs on debian3.1
///////////////////////////
//     std::cout <<"runtime halt ..." << std::endl;
//     toolbox::getRuntime()->halt(0); // hangs on debian3.1
//      std::cout <<"after runtime halt." << std::endl;

///////////////////////////////////
//std::cout <<"abort..." << std::endl;
//abort(); // works, but creates also stacktrace output...
//std::cout <<"after abort..." << std::endl;
////////////////////////////////////////
// std::cout <<"NO Shutdown." << std::endl; 
}


void dabc::xd::Application::actionPerformed (xdata::Event& e) 
{ 
	//std::cout <<"dabc::Application actionPerformed got event type:"<<e.type() << std::endl;
   if (e.type() == "ItemRetrieveEvent")
	{
      // update measurements monitors for xdaq http requests:		
		std::string itemname = dynamic_cast<xdata::ItemRetrieveEvent&>(e).itemName();
		   std::cout <<"dabc::Application ItemRetrieveEvent for item "<<itemname << std::endl;
    
      //LOG4CPLUS_INFO(getApplicationLogger(), toolbox::toString("item retrieve event for %s",item.c_str()));
      // implement in subclass
   }
   else if ((e.type() == "ItemChangedEvent"))
   {
         xdata::ItemChangedEvent& ce=dynamic_cast<xdata::ItemChangedEvent&>(e);
         //std::cout <<"change event pointer is "<< (int*) &ce <<", event pointer is "<<(int*) &e<< std::endl;
         //std::string itemname = dynamic_cast<xdata::ItemChangedEvent&>(e).itemName();
         std::string itemname =ce.itemName();
         
         //std::cout <<"dabc::Application ItemChangedEvent for item "<<itemname << std::endl;
         
          if(itemname==_DABC_SERVICE_STATE_)
            { 
               // have to treat case that state is restored from configuration file!
               // need to update it here according to actual state machine
               //std::cout <<"currentstate was changed to"<<currentState_.toString();
               theState_=fsm_.getCurrentState();
               currentState_=fsm_.getStateName(fsm_.getCurrentState());
               //std::cout <<", reset it to real state name " <<currentState_.toString() << std::endl;
            }
         else if(itemname==_DABC_SERVICE_MESSAGE_)
            {
             //std::cout <<"statusMessage was changed to"<<statusMessage_.toString();
              statusMessage_=fxLastMessage; 
                 //std::cout <<", reset it to " <<statusMessage_.toString() << std::endl;
            }   
         else if(itemname==_DABC_SERVICE_STARTTIME_)
             {
               //std::cout <<"startTime was changed to"<<startTime_.toString();
               startTime_=fuStartTime;  
               //std::cout <<", reset it to " <<startTime_.toString() << std::endl;
            }  
         else if(itemname==_DABC_SERVICE_VERSION_)
             {
               //std::cout <<"DABCVersion was changed to"<<dabcVersion_.toString();
               dabcVersion_=fxVersion;  
               //std::cout <<", reset it to " <<dabcVersion_.toString() << std::endl;
            }  
           else if(itemname==_DABC_SERVICE_NODELIST_)
             {
               //std::cout <<"Nodelist was changed to"<<clusterNodes_.toString();
               clusterNodes_=fxNodes;  
               //std::cout <<", reset it to " <<clusterNodes_.toString() << std::endl;
            }    
          else if(itemname==_DABC_SERVICE_DEBUG_)
            {
               dabc::SetDebugLevel(debugLevel_);
            }
         else
            {  
             	//std::cout <<"+Application::actionPerformed before UpdateDIMService for "<<itemname<< std::endl;
               Registry()->UpdateDIMService(itemname);
               //std::cout <<"-Application::actionPerformed after UpdateDIMService for "<<itemname<< std::endl;
     
            }
   }   
      
}





void dabc::xd::Application::ExecuteLocalCommand(const std::string& com, const std::string& par)
{
if(com==_DABC_COMMAND_SHUTDOWN_)
   {
      std::cout <<"ExecuteLocalCommand sees Shutdown.."<< std::endl;
      Shutdown();     
   }
else if(com==_DABC_COMMAND_SETPAR_)
   {
      Registry()->SetDIMVariable(par);
   }
else if(com==_DABC_COMMAND_LOADPARS_)
   {
      //std::cout <<"LoadParameters string:"<<par <<":"<< std::endl;
      Registry()->LoadParameters(par);
   }   
else if(com==_DABC_COMMAND_SAVEPARS_)
   {
      //std::cout <<"SaveParameters string:"<<par <<":"<< std::endl;
      Registry()->SaveParameters(par);
   }  
else
   {     
      ChangeState(com);
   }         
}













 










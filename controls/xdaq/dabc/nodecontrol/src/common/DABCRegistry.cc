/* Generated by Together */

#include "DABCRegistry.h"
#include "DABCDimServer.h"
#include "DABCExceptions.h"

#include "toolbox/Runtime.h"
#include "xdata/soap/Serializer.h"
#include "xoap/Method.h"
#include "xdaq/NamespaceURI.h"
#include "xoap/MessageReference.h"
#include "xoap/MessageFactory.h"
#include "xoap/SOAPPart.h"
#include "xoap/SOAPEnvelope.h"
#include "xoap/SOAPBody.h"
#include "xoap/SOAPBodyElement.h"
#include "xoap/domutils.h"
#include "xoap/DOMParser.h"
#include "xoap/DOMParserFactory.h"
#include "xcept/tools.h"

#include "dabc/Parameter.h"

const std::string dabc::xd::Registry::serverPrefix_="DABC/";
//const std::string dabc::xd::Registry::serverPrefix_="XDAQ/";

dabc::xd::Registry::Registry(dabc::xd::Application* owner)
	throw (xdaq::exception::Exception)
   : dimPrefixReady_(false), dimServer_(0), theApplication_(owner)
{
   /** protect services used by many threads*/
#if __XDAQVERSION__  > 310
   mainMutex_=new toolbox::BSem(toolbox::BSem::FULL, true);
   parseMutex_=new toolbox::BSem(toolbox::BSem::FULL, true);
#else
   mainMutex_=new BSem(BSem::FULL, true);
   parseMutex_=new BSem(BSem::FULL, true);
#endif

   SetInfoSpace(theApplication_->getApplicationInfoSpace());

   dimServer_=dabc::xd::DimServer::Instance();
   dimServer_->RegisterApplication(this);



   std::string& pre=GetDIMPrefix();
   std::string actionname=pre+"dimaction";
   std::string loopname=pre+"dimloop";
   dimCommandAction_ = toolbox::task::bind (this, &dabc::xd::Registry::ProcessDIMQueue, actionname);
   dimCommandLoop_ = toolbox::task::getWorkLoopFactory()->getWorkLoop(loopname, "waiting");
   dimCommandLoop_->activate();
   actionname=pre+"commandaction";
   loopname=pre+"commandloop";
   localCommandAction_ = toolbox::task::bind (this, &dabc::xd::Registry::ProcessLocalcommandQueue, actionname);
   localCommandLoop_ = toolbox::task::getWorkLoopFactory()->getWorkLoop(loopname, "waiting");
   localCommandLoop_->activate();
   ctrlPars_.clear(); // vector of control paramters
   // the DIM initializations:
   dimServices_.clear();
   dimCommands_.clear();
   fxModuleCommandNames.clear();
   fxParamInfos.clear();
   dimCommandLoop_->submit(dimCommandAction_);
   localCommandLoop_->submit(localCommandAction_);
}

dabc::xd::Registry::~Registry()
{
  DimCommandDescriptor* nul=0;
  fxDimQueue.push(nul); // wake up waiting queue thread
  LocalCommandDescriptor* lnul=0;
  fxLocalComQueue.push(lnul); // wake up waiting queue thread


  RemoveControlParameterAll();
  RemoveDIMServiceAll();
  RemoveDIMCommandsAll();
  //dimServer_->UnRegisterApplication(this);
  dimServer_->Delete(); // note: we destroy dimserver, since we are only application in executive
                        // todo: UnRegisterApplication calls Delete internally when last app unregisters.
  delete parseMutex_;
  delete mainMutex_;
}





//
//
xoap::MessageReference dabc::xd::Registry::HandleSOAPMessage (xoap::MessageReference msg) throw (xoap::exception::Exception)
{
	std::cout <<"\n--------- dabc::xd::Registry HandleSOAPMessage" << std::endl;
	xdata::soap::Serializer serializer;

   std::string parameterName="";
   xoap::SOAPPart part = msg->getSOAPPart();
	xoap::SOAPEnvelope env = part.getEnvelope();
	xoap::SOAPBody body = env.getBody();


	DOMNode* node = body.getDOMNode();
	DOMNodeList* bodyList = node->getChildNodes();
	for (unsigned int i = 0; i < bodyList->getLength(); i++)
	{
		DOMNode* command = bodyList->item(i);
      		if (command->getNodeType() == DOMNode::ELEMENT_NODE)
		{
			std::string commandName = xoap::XMLCh2String (command->getLocalName());
         //// extract first parameter from subnodes
         try
         {
         DOMNodeList* parList = command->getChildNodes();
         for (unsigned int j = 0; j < bodyList->getLength(); j++)
            {
               DOMNode* parnode = parList->item(j);
               xdata::String par;
               serializer.import(&par,parnode);
               parameterName=par;
               std::cout <<"HandleSOAPMessage imports parameter "<<parameterName << std::endl;
               break;
            }
         }
        catch(xdata::exception::Exception &e)
            {
              std::cout <<"HandleSOAPMessage could not import parameter."<< std::endl;
            }
         catch(...)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to get SOAP parameter with unknown exception!\n"));
			}

      //standard response message made from command name:
      xoap::MessageReference reply = xoap::createMessage();
      xoap::SOAPEnvelope envelope = reply->getSOAPPart().getEnvelope();
      try
			{
				OnSOAPCommand(commandName, parameterName, envelope, msg);
         }
      catch (toolbox::fsm::exception::Exception & e)
			{
            //XCEPT_RAISE(xoap::exception::Exception, toolbox::toString("State machine exception %s occured when handling SOAP command %s",e.what(),commandName.c_str()));
            LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to HandleSOAPMessage with FSM exception: %s ",e.what()));
            continue;
         }
      catch(std::exception &e)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to HandleSOAPMessage with standard exception: %s ",e.what()));
				continue;
			}
      catch(...)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to HandleSOAPMessage with unknown exception!\n"));
				continue;
			}
      // print the newly created message to the console
      reply->writeTo(std::cout);
      std::cout << std::endl;
      return reply;
		}
	}

	XCEPT_RAISE(xoap::exception::Exception,"command not found");
}


void dabc::xd::Registry::OnSOAPCommand(std::string& commandName, std::string& parameterName, xoap::SOAPEnvelope &envelope, xoap::MessageReference)
{
  if(commandName==_DABC_COMMAND_GETINFOSPACE_)
      {
         std::cout <<"got command GetInfospace" << std::endl;
         std::ostringstream ratestr;
         ratestr << commandName<<"-Response";
         //  std::cout << "answerstring:"<<ratestr.str();
         xoap::SOAPName responseName = envelope.createName(ratestr.str(), "xdaq", XDAQ_NS_URI);
         xoap::SOAPBodyElement bodyElement = envelope.getBody().addBodyElement ( responseName );
         // test: we put complete serialized infospace into response here!
         xdata::soap::Serializer serializer;

         serializer.exportAll(GetInfoSpace(), dynamic_cast<DOMElement*>(bodyElement.getDOMNode()), true);

      }
  else if(commandName==_DABC_COMMAND_GETSTATUS_)
      {
         std::cout <<"got command GetStatus" << std::endl;
         std::string state=theApplication_->GetState();
         std::cout <<"current state is: "<< state << std::endl;
         xoap::SOAPName responseName = envelope.createName( commandName +"-Response", "xdaq", XDAQ_NS_URI);
         xoap::SOAPBodyElement bodyElement = envelope.getBody().addBodyElement ( responseName );
         /// new: put into child element
          xdata::soap::Serializer serializer;
          xdata::String status=state;
         xoap::SOAPName stateElementName = envelope.createName ("Status", "xdaq", "urn:xdaq-soap:3.0");
         xoap::SOAPElement stateElement = bodyElement.addChildElement(stateElementName);
         serializer.exportAll(&status, dynamic_cast<DOMElement*>(stateElement.getDOMNode()), true);
    }
    else
      {
         PushLocalCommand(commandName, parameterName);
      }
   xoap::SOAPName responseName = envelope.createName( commandName +"Response", "xdaq", XDAQ_NS_URI);
   envelope.getBody().addBodyElement ( responseName );
}







void dabc::xd::Registry::LoadParameters(const std::string filename) throw (xdaq::exception::ParameterSetFailed)
{
   // LockGuard g(mainMutex_); // no guard during dim update
	try
	{
      std::string fullname=CreateFullParameterfileName(filename);
      xoap::DOMParser* parser = xoap::DOMParserFactory::getInstance()->get("DABC_Parser");
      DOMDocument* doc =parser->loadXML(fullname);
      DOMNodeList* dataNode = doc->getElementsByTagNameNS(xoap::XStr(XDAQ_NS_URI), xoap::XStr("properties"));
 		xdata::soap::Serializer serializer;
		GetInfoSpace()->lock(); // workaround for not threadsafe serializer required?
      serializer.import(GetInfoSpace(),dataNode->item(0));
      GetInfoSpace()->unlock();
      xoap::DOMParserFactory::getInstance()->destroy("DABC_Parser");
      theApplication_->StatusMessage(toolbox::toString("Loaded all parameters from %s ", fullname.c_str()),dabc::xd::nameParser::MESSAGE);
	}
	catch (xdata::exception::Exception& xe)
	{
		//XCEPT_RETHROW (xdaq::exception::ParameterSetFailed, "LoadParameters failed", xe);
      GetInfoSpace()->unlock();
      theApplication_->StatusMessage(toolbox::toString("xdata Exception in %s: %s raised in %s:%s", __FUNCTION__ , xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);

   }
   catch (xoap::exception::Exception& xe)
   {
      GetInfoSpace()->unlock();
      //std::cout << "xoap exception in LoadParameters: "<< e.what()<<std::endl;
      theApplication_->StatusMessage(toolbox::toString("xoap Exception in %s: %s raised in %s:%s", __FUNCTION__ , xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);

      //xcept::stdformat_exception_history(e) << std::endl;
   }
   catch (dabc::xd::Exception& xe)
   {
      GetInfoSpace()->unlock();
      theApplication_->StatusMessage(toolbox::toString("DABC Exception in %s: %s raised in %s:%s", __FUNCTION__ , xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
   catch (...)
	{
      GetInfoSpace()->unlock();
      //std::cout << "unknown exception in LoadParameters: "<<std::endl;
      theApplication_->StatusMessage(toolbox::toString("Unexpected Exception in %s ", __FUNCTION__),dabc::xd::nameParser::ERR);

   }

}

void dabc::xd::Registry::SaveParameters(const std::string filename)
{
try
	{
      std::string fullname=CreateFullParameterfileName(filename);
      // set up message with envelope:
      xoap::MessageReference msg = xoap::createMessage();
      xoap::SOAPEnvelope envelope = msg->getSOAPPart().getEnvelope();
      xoap::SOAPBody body = envelope.getBody();
      xoap::SOAPName bodyElementName = envelope.createName("properties", "xdaq", XDAQ_NS_URI);
      xoap::SOAPBodyElement bodyElement = body.addBodyElement ( bodyElementName );
      xdata::soap::Serializer serializer;
      GetInfoSpace()->lock(); // workaround for not threadsafe serializer required?
      serializer.exportAll(GetInfoSpace(), dynamic_cast<DOMElement*>(bodyElement.getDOMNode()), true);
      GetInfoSpace()->unlock();
      // now put message to file:
      std::ofstream outfile(fullname.c_str());
      msg->writeTo(outfile);
      theApplication_->StatusMessage(toolbox::toString("Saved all parameters to %s ", fullname.c_str()),dabc::xd::nameParser::MESSAGE);
      // print on screen for control:
//      msg->writeTo(std::cout);
//      std::cout << std::endl;

   }
catch (xdata::exception::Exception& xe)
	{
      GetInfoSpace()->unlock();
      theApplication_->StatusMessage(toolbox::toString("xdata Exception in %s: %s raised in %s:%s", __FUNCTION__ , xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (xoap::exception::Exception& xe)
   {
      GetInfoSpace()->unlock();
      theApplication_->StatusMessage(toolbox::toString("xoap Exception in %s: %s raised in %s:%s", __FUNCTION__ , xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (dabc::xd::Exception& xe)
   {
      GetInfoSpace()->unlock();
      theApplication_->StatusMessage(toolbox::toString("DABC Exception in %s: %s raised in %s:%s", __FUNCTION__ , xe.name().c_str(),xe.function().c_str(), xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
catch (...)
	{
      GetInfoSpace()->unlock();
      theApplication_->StatusMessage(toolbox::toString("Unexpected Exception in %s ", __FUNCTION__),dabc::xd::nameParser::ERR);

   }


}

std::string dabc::xd::Registry::CreateFullParameterfileName(std::string namex)
{
std::string name=toolbox::trim(namex); // strip blanks
if(name=="" || name.empty())
      {
         name="default";
      }
   std::string contextname=GetDIMServerName();

   std::string::size_type start=contextname.find(serverPrefix_); // look for XDAQ/ and strip it
   std::string::size_type end=start+ serverPrefix_.length();
   //int start=contextname.find("XDAQ/");
   //int end=start+5; // length of XDAQ prefix string
   if(start!=std::string::npos) // only replace if prefix was found
      {
         contextname.replace(start, end,"");
      }
   std::string appname=GetUniqueApplicationName();
   //std::string fname=contextname+"-"+appname+"-"+name+".xml";
   std::string fname="DABCParameters-"+contextname+"-"+appname+"-"+name+".xml";

   return fname;
}







std::string dabc::xd::Registry::GetDIMServerName(xdaq::ContextDescriptor* cd)
{
 std::string servname;
 if(cd==0) // use own context
      servname=theApplication_->getApplicationContext()->getContextDescriptor()->getURL();
 else
      servname=cd->getURL();
 std::string::size_type start=servname.find("http://");
 std::string::size_type end=start+7; // length of http prefix string
 if(start!=std::string::npos) // only replace http:// if it was found
   {
      servname.replace(start, end,"");
   }
 std::string prefix=serverPrefix_;//"XDAQ/"
/// we disable zone prefix for the moment since we do not use this feature anyway
// might cause confusion when serverPrefix is used for evaluating names in user classes
//#if __XDAQVERSION__  > 36
// std::set<std::string> l = getApplicationContext()->getZoneNames();
// std::set<std::string>::iterator i = l.begin(); // we ignore any other zone assignements for the prefix
// std::string zone=*i;
// //std::cout <<"GetDIMServerName found first zone:"<<zone << std::endl;
// if(zone!="default")
//   {
//    //std::cout <<"not running in default zone, using zone prefix" << std::endl;
//    prefix=zone+"/";
//   }
//#endif
 std::string retval=prefix+servname; // later get global prefix from config
 //std::cout <<"GetDIMServerName returns "<<retval << std::endl;
 return retval;
}



std::string dabc::xd::Registry::BuildDIMName(const std::string& localname)
{
 std::string& prefix=GetDIMPrefix();
 std::string dimname=prefix+localname;
 return dimname;

}

std::string dabc::xd::Registry::ReduceDIMName(const std::string& dimname)
{
 std::string rname=dimname;
   //std::cout <<"ReduceDIMName for "<<rname<< std::endl;

 std::string& prefix=GetDIMPrefix();
   //std::cout <<"   ReduceDIMName uses prefix "<<prefix<< std::endl;

 std::string::size_type start=rname.find(prefix);
 std::string::size_type end=start+prefix.length();
 //std::cout <<"   ReduceDIMName: start="<<start<<", end="<<end << std::endl;
 if(start!=std::string::npos) // only replace dim prefix if it was found
   {
      rname.replace(start, end,"");
   }
  //std::cout <<"ReduceDIMName returns "<<rname<< std::endl;
 return rname;
}

std::string& dabc::xd::Registry::GetDIMPrefix()
{
if(!dimPrefixReady_)
{
   dimPrefix_=CreateDIMPrefix();
   dimPrefixReady_=true;
}
return dimPrefix_;
}

std::string dabc::xd::Registry::CreateDIMPrefix(xdaq::ContextDescriptor* cd, xdaq::ApplicationDescriptor* ad)
{
std::string contextname=GetDIMServerName(cd);
std::string appname=GetUniqueApplicationName(ad);
std::string result=contextname+"/"+appname+"/";
return result;
}



std::string dabc::xd::Registry::GetUniqueApplicationName(xdaq::ApplicationDescriptor* ad)
{
 if(ad==0)
   ad=theApplication_->getApplicationDescriptor(); // default: for this application
 std::string classname= ad->getClassName();
// WORKAROUND for java gui:
// strip all namespaces from classname (later handle namespace in gui)
std::string::size_type end=0;
while((end=classname.find("::"))!=std::string::npos)
   {
      classname.replace(0, end+2,"");
      //std::cout <<"GetUniqueApplicationName strips: "<<classname<<  std::endl;

   }
////////////////////////// END WORKAROUND
 std::string lid=toolbox::toString("%d",ad->getLocalId());
 std::string uan=classname+":"+lid;
 //std::cout <<"GetUniqueApplicationName returns: "<<uan<<  std::endl;
 return uan;

}


std::string dabc::xd::Registry::CreateFullParameterName(const std::string& modulename, const std::string& varname)
{
LockGuard g(parseMutex_);
if(modulename=="") return varname;
std::string registername="";
const char* rname=dabc::xd::nameParser::createFullParameterName(modulename.c_str(),varname.c_str());
if(rname) registername=rname; // cannot init std::string from null char* ptr
// TODO: exception if parsing fails
return registername;

}


void dabc::xd::Registry::ParseFullParameterName(const std::string& fullname, std::string& modname, std::string& varname)
{
LockGuard g(parseMutex_);
char* mod=0;
char* var=0;
nameParser::parseFullParameterName(fullname.c_str(), &mod, &var);
if(mod)
   modname=mod;
else
   modname=""; // need this to avoid std::string exception
if(var)
   varname=var;
else
   varname="";
// TODO: exception if parsing fails
}

std::string dabc::xd::Registry::CreateCommandDescriptorName(const std::string& commandname)
{
LockGuard g(parseMutex_);
std::string descrname="";
const char* dname=nameParser::createCommandDescriptorName(commandname.c_str());
if(dname) descrname=dname; // cannot init std::string from null char* ptr
// TODO: exception if parsing fails
return descrname;
}





void dabc::xd::Registry::RegisterSerializable(const std::string &name, xdata::Serializable *serializable, bool dimchangeable, bool setupchangeable)
{
try
   {
      RegisterInfoSpaceAndDIM(name, serializable , false, setupchangeable, dimchangeable);
   }
catch (xdata::exception::Exception& xe) // catch case of duplicate infospace entries
   {
       theApplication_->StatusMessage(toolbox::toString("xdata exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str() , xe.message().c_str()),dabc::xd::nameParser::ERR);
   }
}





void dabc::xd::Registry::RegisterInfoSpaceAndDIM(const std::string &name, xdata::Serializable *serializable,
            bool retrievelistener, bool changelistener, bool allowdimchange,  bool iscommanddescriptor,
            xdata::ActionListener* listener)
        throw (xdata::exception::Exception)
{
   // NOTE: no main mutex lock for whole method
   // dim and infospace are locked by internal mutexes
   // our main mutex will protect dabc lists only to avoid deadlocking
  /////////////////////////////////
  // put the variable to dim first:
   std::string dimname=BuildDIMName(name);
   if(FindDIMService(name)!=0)
      {
             std::cout <<"RegisterInfoSpaceAndDIM: service "<<name<<" already exisiting!" << std::endl;
             throw (xdata::exception::Exception( "Duplicate service",toolbox::toString("service %s already existing!",name.c_str()), __FILE__, __LINE__, __FUNCTION__ ));
      }
   dabc::xd::DimServiceEntry* nentry= new dabc::xd::DimServiceEntry(serializable,dimname, 0 ); // mainMutex_);
   if(allowdimchange)
            nentry->SetVisibility(DABC_VIS_MONITOR | DABC_VIS_CHANGABLE);
   else
            nentry->SetVisibility(DABC_VIS_MONITOR);
   if(iscommanddescriptor)
         {
             nentry->SetType(dabc::xd::nameParser::COMMANDDESC);
             nentry->SetVisibility(0);
         }
   // put to our own service list:
   { // begin lock
    LockGuard g(mainMutex_);
      dimServices_.push_back(nentry);
   } // end lock

  // then register infospace listeners
  if(listener==0) listener=theApplication_;
  GetInfoSpace()->fireItemAvailable(name,serializable);
  if(retrievelistener)
   {
     // Add infospace listeners for exporting data values
      GetInfoSpace()->addItemRetrieveListener (name, listener);
      //std::cout <<"registered item retrieve listener for "<<name << std::endl;
   }
  if(changelistener)
   {
     // Add infospace listeners for exporting data values
      GetInfoSpace()->addItemChangedListener (name, listener);
      //std::cout <<"registered item change listener for "<<name << std::endl;
   }

}

void dabc::xd::Registry::UnRegisterSerializable(const std::string &name)
{
try
{
    //std::cout <<" enter UnRegisterSerializable for"<< name <<std::endl;
    GetInfoSpace()->fireItemRevoked(name);
    RemoveDIMService(name);
}
catch(xdata::exception::Exception& e)
{
      LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to unregister infospace variable with xdata exception: %s ",e.what()));
}
catch(std::exception &e)
   {
      LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to unregister infospace variable with standard exception: %s ",e.what()));
   }
catch(...)
   {
      LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to unregister infospace variable with unknown exception!\n"));
   }


}

dabc::xd::DimServiceEntry* dabc::xd::Registry::FindDIMService(std::string name)
{
dabc::xd::DimServiceEntry* ret=0;
LockGuard g(mainMutex_);
//std::cout <<"fffffffff FindDIMService is looking for -"<<name<<"-" << std::endl;

std::vector<dabc::xd::DimServiceEntry*>::iterator iter;
for(iter=dimServices_.begin(); iter!=dimServices_.end(); ++iter)
	{
		dabc::xd::DimServiceEntry* service=*iter;
		try
			{
              std::string sname=service->getDimName();
              std::string reducedname=ReduceDIMName(sname);
              //std::cout <<"reducedname is -"<<reducedname <<"-"<< std::endl;

              if(name==sname || name==reducedname)
               {
                  //std::cout <<"FindDIMService:checked for dim name "<<name <<", service name is "<<sname << std::endl;
                  ret=service;
                  break;
               }
         }
      catch(std::exception &e)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to find DIM service with standard exception: %s ",e.what()));
				continue;
			}
      catch(...)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to find  DIM service with unknown exception!\n"));
				continue;
			}
	}// for
//std::cout <<"fffffffff FindDIMService returns "<<ret << std::endl;

return ret;

}

bool dabc::xd::Registry::RegisterControlParameter( dabc::xd::ControlParameter* par,
            bool retrievelistener, bool changelistener,
            bool allowdimchange, bool iscommanddescriptor)
{
if(par==0) return false;
{ // start locking
LockGuard g(mainMutex_);
   std::string name=par->Name();
   if(FindControlParameter(name)!=0)
      {
        std::cout <<"RegisterControlParameter: parameter "<<name<<" is already exisiting!" << std::endl;
        delete par;
        return false;
      }
  //std::cout <<"RegisterControlParameter for: "<<name<<"..." << std::endl;
  ctrlPars_.push_back(par);
} // release lockguard from here
try
   {
   RegisterInfoSpaceAndDIM(par->Name(),par->Serializable(),
                           retrievelistener, changelistener,  allowdimchange, iscommanddescriptor, par);
   }
catch (xdata::exception::Exception& xe) // catch case of duplicate infospace entries
   {
       theApplication_->StatusMessage(toolbox::toString("xdata exception in  %s: %s raised in %s:%s", __FUNCTION__, xe.name().c_str(),xe.function().c_str() , xe.message().c_str()),dabc::xd::nameParser::ERR);
       return false;
   }
return true;
}




void dabc::xd::Registry::RegisterControlParameter(std::string& name, xdata::Serializable *serializable, void* reference, bool changable, void (*callback)())
{
ControlParameter* nentry= new ControlParameter(this,
                                                         name,
                                                         serializable,
                                                         (char*) reference,
                                                         callback) ;
RegisterControlParameter(nentry,  true, changable, changable, false);
// no change listener if not changable parameters
}



dabc::xd::ControlParameter* dabc::xd::Registry::FindControlParameter(std::string name)
{
LockGuard g(mainMutex_);
std::vector<dabc::xd::ControlParameter*>::iterator iter;
for(iter=ctrlPars_.begin(); iter!=ctrlPars_.end(); ++iter)
	{
		dabc::xd::ControlParameter* par=*iter;
		try
			{
            std::string sname=par->Name();
            if(sname==name)
               {
                  return par;
               }
         }
      catch(std::exception &e)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to find control parameter %s with standard exception: %s ",name.c_str(), e.what()));
				continue;
			}
      catch(...)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to find control parameter %s with unknown exception!\n",name.c_str()));
				continue;
			}
	}// for
return 0;
}




void dabc::xd::Registry::AddControlParameter(std::string name, int* ref, bool allowchange, void (*callback)())
{
  xdata::Integer* par= new xdata::Integer(*ref);
  RegisterControlParameter(name, par, (void*) ref, allowchange, callback);

}

void dabc::xd::Registry::AddControlParameter(std::string name, unsigned int* ref, bool allowchange, void (*callback)())
{
  xdata::UnsignedInteger* par= new xdata::UnsignedInteger(*ref);
  RegisterControlParameter(name, par, (void*) ref, allowchange, callback);

}
void dabc::xd::Registry::AddControlParameter(std::string name, float* ref, bool allowchange, void (*callback)())
{
  xdata::Float* par= new xdata::Float(*ref);
  RegisterControlParameter(name, par, (void*) ref, allowchange, callback);

}

void dabc::xd::Registry::AddControlParameter(std::string name, double* ref, bool allowchange, void (*callback)())
{
  xdata::Double* par= new xdata::Double(*ref);
  RegisterControlParameter(name, par, (void*) ref, allowchange, callback);

}


void dabc::xd::Registry::AddControlParameter(std::string name, bool* ref, bool allowchange, void (*callback)())
{
  xdata::Boolean* par= new xdata::Boolean(*ref);
  RegisterControlParameter(name, par, (void*) ref, allowchange, callback);

}

void dabc::xd::Registry::AddControlParameter(std::string name, std::string* ref, bool allowchange, void (*callback)())
{
  xdata::String* par= new xdata::String(ref->c_str());
  RegisterControlParameter(name, par, (void*) ref, allowchange, callback);

}


void dabc::xd::Registry::RemoveControlParameter(std::string name)
{
ControlParameter* delpar=0;
   { // begin lock
   LockGuard g(mainMutex_);
   std::vector<ControlParameter*>::iterator iter;
   for(iter=ctrlPars_.begin(); iter!=ctrlPars_.end(); ++iter)
      {
         ControlParameter* par=*iter;
         try
            {
               std::string sname=par->Name();
               if(sname==name)
                  {
                     //std::cout <<"Removing control parameter "<< sname << std::endl;
                     ctrlPars_.erase(iter);
                     delpar= par;
                     break;
                  }
            }
         catch(std::exception &e)
            {
               LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to remove control parameter %s with standard exception: %s ",name.c_str(), e.what()));
               continue;
            }
         catch(...)
            {
               LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to remove control parameter %s with unknown exception!\n",name.c_str()));
               continue;
            }
      }// for
   } // end lock
if(delpar)
   {
    UnRegisterSerializable(name);
    delete delpar;
   }
else
   {
      std::cout <<"Could not remove control parameter "<< name <<": not found!!"<< std::endl;
   }
}

void dabc::xd::Registry::RemoveControlParameterAll()
{
std::vector<ControlParameter*> removepars;
  { // begin lock
   LockGuard g(mainMutex_);
      removepars=ctrlPars_; // backup list of parstructure pointers
      ctrlPars_.clear(); // now "official" list is cleared
   } // end lock

std::vector<ControlParameter*>::iterator iter;
for(iter=removepars.begin(); iter!=removepars.end(); ++iter)
	{
		ControlParameter* par=*iter;
		try
			{
                  UnRegisterSerializable(par->Name());
                  delete par;
         }
      catch(std::exception &e)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to remove control parameter %s with standard exception: %s ",par->Name().c_str(), e.what()));
				continue;
			}
      catch(...)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to remove control parameter %s with unknown exception!\n",par->Name().c_str()));
				continue;
			}
	}// for
}


void dabc::xd::Registry::ChangedControlParameter(void* address)
{
ControlParameter* cpar=0;
{
LockGuard g(mainMutex_);
std::vector<ControlParameter*>::iterator iter;
for(iter=ctrlPars_.begin(); iter!=ctrlPars_.end(); ++iter)
	{
		ControlParameter* par=*iter;
		try
			{
            char* sadd=par->Reference();
            if(sadd== (char*) address)
               {
                  //std::string sname=par->Name();
                  //std::cout <<"Control parameter "<< sname<<" has changed." << std::endl;
                  //par->ChangedReference(); // do this outside mutex lock!
                  cpar=par;
                  break;
               }
         }
      catch(std::exception &e)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed signal control parameter %x change with standard exception: %s ",address, e.what()));
				continue;
			}
      catch(...)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to signal control parameter %x change with unknown exception!\n",address));
				continue;
			}
	}// for
} // endl lockguard
 if(cpar) cpar->ChangedReference();
}


void dabc::xd::Registry::RegisterModuleParameter(std::string& name, xdata::Serializable *serializable,  bool changable, bool commanddescriptor, dabc::Parameter* corepar)
{
   ModuleParameter* nentry= new ModuleParameter(this,
                                                         name,
                                                         serializable,
                                                         corepar) ;
  //std::cout <<"RegisterModuleParameter for: "<<name<<"..." << std::endl;
  RegisterControlParameter(nentry,  false, changable, changable, commanddescriptor);
}


void dabc::xd::Registry::DefineDIMCommand(const std::string &name)
{
   std::string dimname=BuildDIMName(name);
   DimCommand* ncom= new DimCommand(dimname.c_str(), "C", dimServer_);
LockGuard g(mainMutex_); // only protect our own list, do not lock dim
   dimCommands_.push_back(ncom);
   //std::cout <<"added dim command " <<dimname << std::endl;
}

void dabc::xd::Registry::DefineSOAPCommand(const std::string &name)
{
	xoap::bind (this, &dabc::xd::Registry::HandleSOAPMessage, name.c_str(), XDAQ_NS_URI);


}


void dabc::xd::Registry::StartDIMServer(const std::string& dnsnode, unsigned int dnsport)
{
 std::string servname=GetDIMServerName();
 dimServer_->Start(servname,dnsnode,dnsport);
 if(dnsport!=0)
   {
      LOG4CPLUS_INFO(GetApplicationLogger(),toolbox::toString("dabc::xd::Registry starting DIM server of name %s for dns %s:%d",servname.c_str(),dnsnode.c_str(),dnsport));
   }
 else
   {
      LOG4CPLUS_INFO(GetApplicationLogger(),toolbox::toString("dabc::xd::Registry starting DIM server of name %s for DIM_DNS_NODE  %s:%d",servname.c_str(),DimServer::getDnsNode(),DimServer::getDnsPort()));
   }

}

void dabc::xd::Registry::StopDIMServer()
{
//LockGuard g(mainMutex_);
dimServer_->Stop();
LOG4CPLUS_INFO(GetApplicationLogger(), toolbox::toString("DIM server was stopped."));

}

void dabc::xd::Registry::UpdateDIMService(const std::string& name, bool logoutput, dabc::xd::nameParser::recordstat recstat)
{
//std::cout <<"UpdateDIMService for "<<name << std::endl;
dabc::xd::DimServiceEntry* service=FindDIMService(name);
if(service)
   {
      //std::cout <<" - Updating dim service "<< name << std::endl;
      service->SetStatus(recstat);
      dabc::xd::nameParser::visiblemask vis=service->GetVisibility();
      if(logoutput)
         {
            service->SetVisibility(vis | DABC_VIS_LOGGABLE);
            service->UpdateDIM();
         }
      else
         {
            service->SetVisibility(vis & (~DABC_VIS_LOGGABLE));
            service->UpdateDIM();
         }
   }
}

void dabc::xd::Registry::UpdateDIMServiceAll()
{
// LockGuard g(mainMutex_); // no guard during dim update
// may explicitely take and give mutex instad
std::vector<dabc::xd::DimServiceEntry*>::const_iterator iter;
for(iter=dimServices_.begin(); iter!=dimServices_.end(); ++iter)
	{
		dabc::xd::DimServiceEntry* service=*iter;
		try
			{
            std::string sname=service->getDimName();
            //std::cout <<"Updating dim service "<< sname << std::endl;
            service->UpdateDIM();
          }
      catch(std::exception &e)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to update DIM service with standard exception: %s \n",e.what()));
				continue;
			}
      catch(...)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to update DIM service with unknown exception!\n"));
				continue;
			}
	}// for
}

void dabc::xd::Registry::SetDIMVariable(std::string parameter)
{
//LockGuard g(mainMutex_);
//std::cout <<"SetDIMVariable with -"<< parameter<<"-" << std::endl;

std::string::size_type eqpos=parameter.find("=");
if(eqpos==std::string::npos) // no equals sign in parameter!
{
   theApplication_->StatusMessage(toolbox::toString("Wrong parameter format (%s) to set DIM variable!",parameter.c_str()),dabc::xd::nameParser::WARNING);
   return;
}
std::string name(parameter,0,eqpos);
std::string nval(parameter, eqpos+1, std::string::npos);
dabc::xd::DimServiceEntry* service=FindDIMService(name);
if(service)
   {
      //std::cout <<"Setting dim service "<< name << std::endl;
      theApplication_->StatusMessage(toolbox::toString("Setting dim service %s to %s",name.c_str(),nval.c_str()));
      service->SetValue(nval);
      GetInfoSpace()->fireItemValueChanged(name, this);
   }
}

void dabc::xd::Registry::RemoveDIMService(const std::string& name)
{
dabc::xd::DimServiceEntry* remservice=0;
{ // begin lockguard
   LockGuard g(mainMutex_);
   std::vector<dabc::xd::DimServiceEntry*>::iterator iter;
   for(iter=dimServices_.begin(); iter!=dimServices_.end(); ++iter)
      {
         dabc::xd::DimServiceEntry* service=*iter;
         try
            {
                 std::string sname=service->getDimName();
                 std::string reducedname=ReduceDIMName(sname);
                 if(name==sname || name==reducedname)
                  {
                     //std::cout <<"Removing dim service "<< sname <<", pointer="<<(int*) service << std::endl;
                     dimServices_.erase(iter);
                     remservice=service;
                     break;
                  }
            }
         catch(std::exception &e)
            {
               LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to remove DIM service with standard exception: %s ",e.what()));
               continue;
            }
         catch(...)
            {
               LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to remove DIM service with unknown exception!\n"));
               continue;
            }
      }// for
} // end lockguard
delete remservice; // delete outside lock to avoid conflict with dim
//std::cout <<"   deleted service "<< (int*) remservice << std::endl;

}





void dabc::xd::Registry::RemoveDIMServiceAll()
{
std::vector<dabc::xd::DimServiceEntry*> removeservices;
  { // begin lock
   LockGuard g(mainMutex_);
      removeservices=dimServices_; // backup list of service pointers
      dimServices_.clear(); // now "official" list is cleared
   } // end lock
// actual deletion of dim services outside our lock:
std::vector<dabc::xd::DimServiceEntry*>::const_iterator iter;
for(iter=removeservices.begin(); iter!=removeservices.end(); ++iter)
	{
		dabc::xd::DimServiceEntry* service=*iter;
		try
			{
            std::string sname=service->getDimName();
            //std::cout <<"Removing dim service "<< sname << std::endl;
            delete service;
            //*iter=0;
         }
      catch(std::exception &e)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to remove DIM service with standard exception: %s \n",e.what()));
				continue;
			}
      catch(...)
			{
				LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to remove DIM service with unknown exception!\n"));
				continue;
			}
	}// for
}

void dabc::xd::Registry::RemoveDIMCommand(const std::string& name)
{
DimCommand* remcom=0;
{  // begin lock
   LockGuard g(mainMutex_);
   std::vector<DimCommand*>::iterator iter;
   for(iter=dimCommands_.begin(); iter!=dimCommands_.end(); ++iter)
      {
         DimCommand* com=*iter;
         try
            {
               std::string sname=com->getName();
               std::string reducedname=ReduceDIMName(sname);
               if(name==sname || name==reducedname)
                  {
                     //std::cout <<"Removing dim command "<< sname << std::endl;
                     dimCommands_.erase(iter);
                     remcom=com;
                     break;
                  }
            }
         catch(std::exception &e)
            {
               LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to remove DIM service with standard exception: %s ",e.what()));
               continue;
            }
         catch(...)
            {
               LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to remove DIM service with unknown exception!\n"));
               continue;
            }
      }// for
} // end lock
delete remcom; // delete dim command outside main lock
}





void dabc::xd::Registry::RemoveDIMCommandsAll()
{
   std::vector<DimCommand*> removecommands;
   { // begin lock
   LockGuard g(mainMutex_);
      removecommands=dimCommands_; // backup list of command pointers
      dimCommands_.clear(); // now "official" list is cleared
   } // end lock
   // delete dim commands in backuped list outside lock:
   std::vector<DimCommand*>::const_iterator iter;
   for(iter=removecommands.begin(); iter!=removecommands.end(); ++iter)
      {
         DimCommand* com=*iter;
         try
            {
               std::string sname=com->getName();
               //std::cout <<"Removing dim command"<< sname << std::endl;
               delete com;
            }
         catch(std::exception &e)
            {
               LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::Application failed to remove DIM service with standard exception: %s \n",e.what()));
               continue;
            }
         catch(...)
            {
               LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::Application failed to remove DIM service with unknown exception!\n"));
               continue;
            }
      }// for
}



void dabc::xd::Registry::HandleDIMCommand(DimCommand* com)
{
// debug:
//std::cout <<"dabc::Registry DIM command handler:"<< std::endl;
//std::cout <<"Got command "<< com->getName() << std::endl;
//std::cout <<"\t string:"<<com->getString()<< std::endl;
//std::cout <<"\t int:"<<com->getInt()<< std::endl;
//std::cout <<"\t float:"<<com->getFloat()<< std::endl;
//std::cout <<"\t double:"<<com->getDouble()<< std::endl;



// check for one of our registered commands:
bool found=false;
{
LockGuard g(mainMutex_);
   std::vector<DimCommand*>::const_iterator iter;
   for(iter=dimCommands_.begin(); iter!=dimCommands_.end(); ++iter)
      {
         DimCommand* regcom=*iter;
         try
            {
               if(com==regcom)
                  {
                     found=true;
                     break;
                  }

            }
         catch(std::exception &e)
            {
               LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to HandleDIMCommand with standard exception: %s ",e.what()));
               continue;
            }
         catch(...)
            {
               LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to HandleDIMCommand with unknown exception!\n"));
               continue;
            }
      }// for
} // end lockguard
// invoke command outside mainmutex to avoid deadlock
if(found) OnDIMCommand(com);
// application subclasses may implement specific handler
}


void dabc::xd::Registry::OnDIMCommand(DimCommand* com)
{
std::string cname=com->getName();
//std::cout <<"found command "<< cname << std::endl;
std::string rname=ReduceDIMName(cname);
std::string par=com->getString();
PushLocalCommand(rname,par); // decouple execution from dim thread!
}




void dabc::xd::Registry::SendDIMCommand(xdaq::ApplicationDescriptor* ad, const std::string& comname, const std::string& par)

{
try{
   xdaq::ContextDescriptor* cd=ad->getContextDescriptor();
   // now build full command name:
   std::string fullcommand=CreateDIMPrefix(cd,ad)+comname;
   std::string password="x1gSFfpv0JvDA"; // get this from environment later!
   std::string parameter=password+" "+par; // blank in between!

   //std::cout <<"SendDIMCommand with cmd="<<fullcommand<<", par="<<parameter << std::endl;
   int ret=DimClient::sendCommand (fullcommand.c_str(), (char*) parameter.c_str());
   if(ret!=1)
            LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry::SendDIMCommand failed with return code %d",ret));
//   // note that DIM return code is unreliable when we send from within command callback!
   }
catch(xdaq::exception::Exception& e)
   {
      // have to treat the cases that destination node  is not known (was not in xml config)
      // or that node is known from config, but not running/available via http post
      LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry::SendDIMCommand failed: %s in (%s:%s):%s",e.name().c_str(),e.module().c_str(),e.function().c_str(),e.what()));
   }
catch(std::exception& e)
   {
      LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry::SendDIMCommand failed with exception:%s",e.what()));
   }
catch(...)
    {
      LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry::SendDIMCommand failed: %s in (%s:%s): unexpected exception!"));

    }



}

void dabc::xd::Registry::SendDIMCommandAsync(xdaq::ApplicationDescriptor* ad, const std::string& comname, const std::string& par)
{
 //std::cout <<"SendDIMCommandAsync for "<<ad<<" com:"<<comname<<", par:"<<par << std::endl;
 DimCommandDescriptor* descr = new  DimCommandDescriptor(ad,comname,par);
 fxDimQueue.push(descr);
}





bool dabc::xd::Registry::ProcessDIMQueue(toolbox::task::WorkLoop* wl)
{
   DimCommandDescriptor* descr=fxDimQueue.pop();
   if(descr==0) return false; // terminate thread
//   std::cout <<"ProcessDIMQueue finds "<<descr->ad_<<" com:"<<descr->comname_<<", par:"<<descr->par_ << std::endl;
//   std::cout <<"callback mode is now=" <<DimCore::inCallback<< std::endl;
   SendDIMCommand(descr->ad_, descr->comname_, descr->par_);
   delete descr;
   return true; // keep workloop alive
}




void dabc::xd::Registry::PushLocalCommand(const std::string& com, const std::string& par)
{
LocalCommandDescriptor* descr = new  LocalCommandDescriptor(com,par);
fxLocalComQueue.push(descr);
}





bool dabc::xd::Registry::ProcessLocalcommandQueue(toolbox::task::WorkLoop* wl)
{
LocalCommandDescriptor* descr=fxLocalComQueue.pop();
//std::cout <<"ProcessLocalcommandQueue after pop.."<<std::endl;
if(descr==0) return false; // terminate thread
std::cout <<"ProcessLocalcommandQueue finds  com:"<<descr->comname_<<", par:"<<descr->par_ << std::endl;
// here check for password:
//std::string parameter=descr->par_;
if(descr->par_.length()<13)
   {
      std::cout<<" - ERROR: parameter too short:"<<descr->par_.length() << std::endl;
      return true;
   }
std::string password=descr->par_.substr(0,13);
// add password check here:
std::string parameter=" - no parameter -";
if(descr->par_.length()>14)
   parameter=descr->par_.substr(14);
std::cout <<"      password:"<<password <<", parameter:"<<parameter<<"," << std::endl;




theApplication_->ExecuteLocalCommand(descr->comname_, parameter);
delete descr;
return true; // keep workloop alive



}




void dabc::xd::Registry::OnExitDIMClient(const char* name)
{
std::string classname=theApplication_->getApplicationDescriptor()->getClassName();
std::cout <<"dabc::xd::Registry client exit handler (class "<<classname <<") for client "<< name << std::endl;
// here we may react on special clients...


}

void dabc::xd::Registry::OnExitDIMServer(int code)
{
std::string classname=theApplication_->getApplicationDescriptor()->getClassName();
std::cout <<"dabc::xd::Registry DIM server exit handler (class "<<classname <<") , code="<<code << std::endl;
////if(code==42) // disabled check for the moment. TODO: access control!
//   {
PushLocalCommand(_DABC_COMMAND_SHUTDOWN_,"x1gSFfpv0JvDA");
//std::cout <<"dabc::xd::Registry DIM server exit handler pushed shutdown command" << std::endl;
//}
}


void dabc::xd::Registry::OnErrorDIMServer(int severity, int code, char *msg)
{
switch(severity)
   {
   case DIM_INFO:
      LOG4CPLUS_INFO(GetApplicationLogger(), toolbox::toString("DIM: %s (code=%d) \n",msg,code));
      break;
   case DIM_WARNING:
      LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("DIM: %s (code=%d) \n",msg,code));
      break;
   case DIM_ERROR:
   case DIM_FATAL:
      LOG4CPLUS_ERROR(GetApplicationLogger(), toolbox::toString("DIM: %s (code=%d) \n",msg,code));
      break;
   default:
      LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("DIM: %s (code=%d) \n",msg,code));
      break;
   }// switch
}

xoap::MessageReference dabc::xd::Registry::SendSOAP(const std::string& cmd, const std::string& par, const std::string& node, unsigned long targetid)
{
std::cout <<"entering send soap for cmd "<<cmd <<" tid="<<targetid<<", node="<< node<<std::endl;
xoap::MessageReference msg =CreateSOAPCommand(cmd,par);
try{
   xdaq::ContextTable* ctable=theApplication_->getApplicationContext()->getContextTable();
   xdaq::ContextDescriptor* dcontext=ctable->getContextDescriptor(node);
   #if __XDAQVERSION__  > 36
   xdaq::Zone* zone = theApplication_->getApplicationContext()->getDefaultZone();
   xdaq::ApplicationDescriptor * d =zone->getApplicationDescriptor(dcontext, targetid);
   #else
   xdaq::ApplicationGroup* ag=theApplication_->getApplicationContext()->getApplicationGroup();
   xdaq::ApplicationDescriptor * d =ag->getApplicationDescriptor(dcontext, targetid);
   #endif
   xoap::MessageReference reply = theApplication_->getApplicationContext()->postSOAP(msg, d);
   return reply;
   }
catch(xdaq::exception::Exception& e)
   {
      // have to treat the cases that destination node  is not known (was not in xml config)
      // or that node is known from config, but not running/available via http post
      LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry::SendSOAP failed: %s in (%s:%s):%s",e.name().c_str(),e.module().c_str(),e.function().c_str(),e.what()));
      return msg;
   }

}

xoap::MessageReference dabc::xd::Registry::CreateSOAPCommand(const std::string& command, const std::string& parameter)
{
xdata::String par=parameter;
xoap::MessageReference msg = xoap::createMessage();
xoap::SOAPPart soap = msg->getSOAPPart();
xoap::SOAPEnvelope envelope = soap.getEnvelope();
xoap::SOAPBody body = envelope.getBody();
xoap::SOAPName cm = envelope.createName(command,"xdaq", XDAQ_NS_URI);
xoap::SOAPBodyElement bodyElement = body.addBodyElement(cm);
xoap::SOAPName parElementName = envelope.createName ("Parameter", "xdaq", "urn:xdaq-soap:3.0");
xoap::SOAPElement parElement = bodyElement.addChildElement(parElementName);
try
   {
      xdata::soap::Serializer serializer;
      serializer.exportAll(&par, dynamic_cast<DOMElement*>(parElement.getDOMNode()), true);
   }
catch(xdata::exception::Exception &e)
   {
     std::cout <<"CreateSOAPCommand could not export parameter."<< std::endl;
   }
catch(...)
   {
   LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to CreateSOAPCommand parameter with unknown exception!\n"));
   }

return msg;
}



void dabc::xd::Registry::RegisterModuleCommand(std::string name, dabc::CommandDefinition* def)
{
 {  // begin lockguard
    LockGuard g(mainMutex_);
    std::string comname=name;
    if(FindModuleCommand(name))
      {
         std::cout <<"Can not register module command "<<name<<", already exists!" << std::endl;
         return; // better use of exceptions etc. later

      }

    fxModuleCommandNames.push_back(comname);
 } // end lockguard before dim part
 DefineDIMCommand(name);
 std::string descrname=nameParser::createCommandDescriptorName(name.c_str());
 std::string descriptor=def->GetXml();
 AddCommandDescriptorRecord(descrname, descriptor);
}

void dabc::xd::Registry::UnRegisterModuleCommand(std::string name)
{
bool found=false;
try
   {
   LockGuard g(mainMutex_);
   std::vector<std::string>::iterator iter=find(fxModuleCommandNames.begin(),fxModuleCommandNames.end(),name);
   if(iter!=fxModuleCommandNames.end())
      {
          fxModuleCommandNames.erase(iter);
          found=true; // defer unregistering to outside of lock block
      }
   else
      {
            std::cout <<"Can not Unregister module command "<<name<<", not existing!" << std::endl;
      }
   } // end try

catch(std::exception &e)
   {
      LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to UnRegisterModuleCommand with standard exception: %s ",e.what()));

   }
catch(...)
   {
      LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to UnRegisterModuleCommand with unknown exception!\n"));
   }

if(found)
   {
      RemoveDIMCommand(name);
      std::string descname=dabc::xd::nameParser::createCommandDescriptorName(name.c_str());
      RemoveRecord(descname);
   }


}


bool  dabc::xd::Registry::FindModuleCommand(std::string name)
{
bool rev=false;
LockGuard g(mainMutex_);
std::vector<std::string>::iterator iter=find(fxModuleCommandNames.begin(),fxModuleCommandNames.end(),name);
if(iter!=fxModuleCommandNames.end()) rev=true;
return rev;
}


void dabc::xd::Registry::AddSimpleRecord(std::string name, int val, bool changable, dabc::Parameter*  corepar)
{
  xdata::Integer* par= new xdata::Integer(val);
  RegisterModuleParameter(name, par, changable, false, corepar);
}

void dabc::xd::Registry::UpdateSimpleRecord(std::string name, int val)
{
// LockGuard g(mainMutex_); // no guard during dim update
ControlParameter* par = FindControlParameter(name);
if(par!=0)
   {
     xdata::Integer* serInt=dynamic_cast< xdata::Integer*>(par->Serializable());
     if(serInt!=0)
      {
         *serInt=val;
         UpdateDIMService(name);
      }
   }
}

void dabc::xd::Registry::AddSimpleRecord(std::string name, double val, bool changable, dabc::Parameter*  corepar)
{
 xdata::Double* par= new xdata::Double(val);
 RegisterModuleParameter(name, par, changable, false, corepar);
}

void dabc::xd::Registry::UpdateSimpleRecord(std::string name, double val)
{
// LockGuard g(mainMutex_); // no guard during dim update
ControlParameter* par = FindControlParameter(name);
if(par!=0)
   {
     xdata::Double* serDouble=dynamic_cast< xdata::Double*>(par->Serializable());
     if(serDouble!=0)
      {
         *serDouble=val;
         UpdateDIMService(name);
      }
   }
}

void dabc::xd::Registry::AddSimpleRecord(std::string name, std::string val, bool changable, dabc::Parameter*  corepar)
{
 xdata::String* par= new xdata::String(val);
 RegisterModuleParameter(name, par, changable, false, corepar);
}

void dabc::xd::Registry::UpdateSimpleRecord(std::string name, std::string val)
{
// LockGuard g(mainMutex_); // no guard during dim update
ControlParameter* par = FindControlParameter(name);
if(par!=0)
   {
     xdata::String* serString=dynamic_cast< xdata::String*> (par->Serializable());
     if(serString!=0)
      {
         *serString=val;
         UpdateDIMService(name);
      }
   }
}



void dabc::xd::Registry::AddCommandDescriptorRecord(std::string name, std::string descr)
{
 xdata::String* par= new xdata::String(descr);
 RegisterModuleParameter(name, par, false, true);

}





void dabc::xd::Registry::AddRateRecord(std::string name, float val, int displaymode,
                        float ll, float ul, float la, float ua,
                        std::string color, std::string alcol,
                        std::string units, dabc::Parameter*  corepar)
{
xdata::Bag<dabc::xd::RateRecord> * rec = new xdata::Bag<dabc::xd::RateRecord>;

rec->bag.rate_=val;
rec->bag.displayMode_=displaymode;
rec->bag.loLimit_=ll;
rec->bag.upLimit_=ul;
rec->bag.loAlarm_=la;
rec->bag.upAlarm_=ua;
rec->bag.color_=color;
rec->bag.colorAlarm_=alcol;
rec->bag.units_=units;
RegisterModuleParameter(name, rec, false, false, corepar); // not changable


}

void dabc::xd::Registry::AddRateRecord(std::string name, dabc::RateRec* rate, dabc::Parameter*  corepar)
{
AddRateRecord(name, rate->value, rate->displaymode, rate->lower, rate->upper,
                     rate->alarmlower, rate->alarmupper, rate->color, rate->alarmcolor,
                     rate->units, corepar);
}




void dabc::xd::Registry::UpdateRateRecord(std::string name, float val, int displaymode,
                        float ll, float ul, float la, float ua,
                        std::string color, std::string alcol,
                        std::string units)
{
// LockGuard g(mainMutex_); // no guard during dim update
ControlParameter* par = FindControlParameter(name);
if(par!=0)
   {
     xdata::Bag<dabc::xd::RateRecord>* serRate=dynamic_cast<xdata::Bag<dabc::xd::RateRecord> *>(par->Serializable());
     if(serRate!=0)
      {
         serRate->bag.rate_=val;
         if(displaymode!=-1)
            {
               serRate->bag.displayMode_=displaymode;
               serRate->bag.loLimit_=ll;
               serRate->bag.upLimit_=ul;
               serRate->bag.loAlarm_=la;
               serRate->bag.upAlarm_=ua;
               serRate->bag.color_=color;
               serRate->bag.colorAlarm_=alcol;
               serRate->bag.units_=units;
               //std::cout <<"Set rate record "<<name<<" to "<<val<<", fully set" <<std::endl;
            }
         else
            {
             //std::cout <<"Updated rate record "<<name<<" to "<<val <<std::endl;
            }
         UpdateDIMService(name);
      }
   }
}


void dabc::xd::Registry::UpdateRateRecord(std::string name, dabc::RateRec* rate)
{
UpdateRateRecord(name, rate->value, rate->displaymode, rate->lower, rate->upper,
                     rate->alarmlower, rate->alarmupper, rate->color, rate->alarmcolor,
                     rate->units);

}



void dabc::xd::Registry::AddStatusRecord(std::string name, std::string status, int severity, std::string color, dabc::Parameter*  corepar)
{
xdata::Bag<dabc::xd::StatusRecord> * rec = new xdata::Bag<dabc::xd::StatusRecord>;
rec->bag.severity_=severity;
rec->bag.color_=color;
rec->bag.status_=status;
RegisterModuleParameter(name, rec, false, false, corepar); // not changable
}

void dabc::xd::Registry::AddStatusRecord(std::string name, dabc::StatusRec* status,  dabc::Parameter* corepar)
{
AddStatusRecord(name,status->status, status->severity, status->color, corepar);

}


void dabc::xd::Registry::UpdateStatusRecord(std::string name, std::string status, int severity, std::string color)
{
// LockGuard g(mainMutex_); // no guard during dim update
ControlParameter* par = FindControlParameter(name);
if(par!=0)
   {
      xdata::Bag<dabc::xd::StatusRecord>* serState=dynamic_cast<xdata::Bag<dabc::xd::StatusRecord> *>(par->Serializable());
      if(serState!=0)
         {
            serState->bag.status_=status;
            if(severity!=-1)
               {
                  serState->bag.severity_=severity;
                  serState->bag.color_=color;
                  //std::cout <<"Set status record "<<name<<" to "<<status<<", fully set" <<std::endl;
               }
            else
               {
                //std::cout <<"Updated status record "<<name<<" to "<<status <<std::endl;
               }
            UpdateDIMService(name);
         }
   }
}

void dabc::xd::Registry::UpdateStatusRecord(std::string name, dabc::StatusRec* status)
{
UpdateStatusRecord(name,status->status, status->severity, status->color);
}

///////////////
void dabc::xd::Registry::AddInfoRecord(std::string name, std::string info, int verbosity, std::string color, dabc::Parameter*  corepar)
{
xdata::Bag<dabc::xd::InfoRecord> * rec = new xdata::Bag<dabc::xd::InfoRecord>;
rec->bag.verbosity_=verbosity;
rec->bag.color_=color;
rec->bag.info_=info;
RegisterModuleParameter(name, rec, false, false, corepar); // not changable
}

void dabc::xd::Registry::AddInfoRecord(std::string name, dabc::InfoRec* info,  dabc::Parameter* corepar)
{
AddInfoRecord(name,info->info, info->verbose, info->color, corepar);

}


void dabc::xd::Registry::UpdateInfoRecord(std::string name, std::string info, int verbosity, std::string color)
{
// LockGuard g(mainMutex_); // no guard during dim update
ControlParameter* par = FindControlParameter(name);
if(par!=0)
   {
      xdata::Bag<dabc::xd::InfoRecord>* serInfo=dynamic_cast<xdata::Bag<dabc::xd::InfoRecord> *>(par->Serializable());
      if(serInfo!=0)
         {
            serInfo->bag.info_=info;
            if(verbosity!=-1)
               {
                  serInfo->bag.verbosity_=verbosity;
                  serInfo->bag.color_=color;
               }
            else
               {
                //std::cout <<"Updated inforecord "<<name<<" to "<<info <<std::endl;
               }
            UpdateDIMService(name);
         }
   }
}

void dabc::xd::Registry::UpdateInfoRecord(std::string name, dabc::InfoRec* info)
{
UpdateInfoRecord(name, info->info, info->verbose, info->color);
}




/////////////

void dabc::xd::Registry::AddHistogramRecord(std::string name,
                                int channels,
                                float xlow,
                                float xhigh,
                                int* data,
                                std::string xlett,
                                std::string cont,
                                std::string color,
                                dabc::Parameter*  corepar
                                    )
{
xdata::Bag<dabc::xd::HistogramRecord> * rec = new xdata::Bag<dabc::xd::HistogramRecord>;
rec->bag.channels_=channels;
rec->bag.xLow_=xlow;
rec->bag.xHigh_=xhigh;
rec->bag.xLett_=xlett;
rec->bag.cont_=cont;
rec->bag.color_=color;
rec->bag.data_.reserve(channels);
for(int j=0; j<channels; ++j)
   {
     rec->bag.data_[j]=data[j];
   }
RegisterModuleParameter(name, rec, false, false, corepar); // not changable
}

void dabc::xd::Registry::AddHistogramRecord(std::string name, dabc::HistogramRec* his,  dabc::Parameter*  corepar)
{
   AddHistogramRecord(name,his->channels, his->xlow, his->xhigh, &(his->data),
                      his->xlett, his->cont, his->color, corepar);

}




void dabc::xd::Registry::UpdateHistogramRecord(std::string name,
                                int channels,
                                float xlow,
                                float xhigh,
                                int* data,
                                std::string xlett,
                                std::string cont,
                                std::string color)
{
//LockGuard g(mainMutex_); // during dim update no guard
ControlParameter* par = FindControlParameter(name);
if(par!=0)
   {
      xdata::Bag<dabc::xd::HistogramRecord>* rec=dynamic_cast<xdata::Bag<dabc::xd::HistogramRecord> *>(par->Serializable());
      if(rec!=0)
         {
            rec->bag.channels_=channels;
            rec->bag.xLow_=xlow;
            rec->bag.xHigh_=xhigh;
            rec->bag.cont_=cont;
            rec->bag.color_=color;
            for(int j=0; j<channels; ++j)
               {
                 rec->bag.data_[j]=data[j];
               }
            UpdateDIMService(name);
         }
   }
}

void dabc::xd::Registry::UpdateHistogramRecord(std::string name, dabc::HistogramRec* his)
{
 UpdateHistogramRecord(name,his->channels, his->xlow, his->xhigh, &(his->data),
                      his->xlett, his->cont, his->color);
}




void dabc::xd::Registry::FillHistogramRecord(std::string name, int bin, int value)
{
// LockGuard g(mainMutex_); // no guard during dim update
ControlParameter* par = FindControlParameter(name);
if(par!=0)
   {
      xdata::Bag<dabc::xd::HistogramRecord>* rec=dynamic_cast<xdata::Bag<dabc::xd::HistogramRecord> *>(par->Serializable());
      if(rec!=0)
         {
            int max=rec->bag.channels_;
            if(bin>max) bin=max;
            if(bin<0) bin=0;
            rec->bag.data_[bin]=rec->bag.data_[bin]+value;  // operator += not defined for xdata::Vector
            UpdateDIMService(name);
         }
   }
}

void dabc::xd::Registry::ClearHistogramRecord(std::string name)
{
// LockGuard g(mainMutex_); // no guard during dim update
ControlParameter* par = FindControlParameter(name);
if(par!=0)
   {
      xdata::Bag<dabc::xd::HistogramRecord>* rec=dynamic_cast<xdata::Bag<dabc::xd::HistogramRecord> *>(par->Serializable());
      if(rec!=0)
         {
            int channels= (int) rec->bag.channels_;
            for(int j=0; j<channels; ++j)
               {
                 rec->bag.data_[j]=0;
               }
             UpdateDIMService(name);
         }
   }
}

void dabc::xd::Registry::RemoveRecord(std::string name)
{
   RemoveControlParameter(name);
}



bool  dabc::xd::Registry::SubscribeParameter(dabc::Parameter* par, const std::string& fulldimname)
{
// TODO: messages as StatusMessages or loginfo output
if(par==0) return false;
try
   {
   //std::cout <<"try to subscribe parameter"<<fulldimname << std::endl;
   if(UnsubscribeParameter(par))
   {
      std::cout <<"!!!!!!!! Warning: a parameter of same address "<<(int*) par <<" was already subscribed (removed it)."<< std::endl;
   }
   // check type of parameter to specify correct callback here?
   // or use one ctor that does it all internally? Maybe problem with ctor inheritance then.
   DimParameterInfo* subscription=0;
   dabc::DoubleParameter* pdouble=dynamic_cast<dabc::DoubleParameter*>(par);
   dabc::StrParameter* pstring  =dynamic_cast<dabc::StrParameter*>(par);
   dabc::IntParameter* pint  =dynamic_cast<dabc::IntParameter*>(par);
   dabc::StatusParameter* pstat  =dynamic_cast<dabc::StatusParameter*>(par);
   dabc::RateParameter* prate  =dynamic_cast<dabc::RateParameter*>(par);
   dabc::HistogramParameter* phis  =dynamic_cast<dabc::HistogramParameter*>(par);

   if(pdouble)
      {
         double defval=-1;
         defval=pdouble->GetDouble();
         subscription=new DimParameterInfo(par, fulldimname.c_str(), defval);
      }
   else if (pstring)
      {
         std::string defval;
         if (!par->GetValue(defval)) defval = "- not connected -";
         subscription=new DimParameterInfo(par, fulldimname.c_str(), (char*) defval.c_str());
      }
   else if (pint)
      {
         int defval=-1;
         defval=pint->GetInt();
         subscription=new DimParameterInfo(par, fulldimname.c_str(), defval);
      }
   else if (pstat)
      subscription=new DimParameterInfo(par, fulldimname.c_str(), (void*) "not", 3 );
   else if (prate)
      subscription=new DimParameterInfo(par, fulldimname.c_str(), (void*) "not", 3 );
   else if (phis)
      subscription=new DimParameterInfo(par, fulldimname.c_str(), (void*) "not", 3 );
   else
      std::cout <<"!!!!!!!!! Never come here: unknown parameter type in SubscribeParameter for " <<par->GetName()<< std::endl;
   if(subscription)
      {
         LockGuard g(mainMutex_);  // only protect our own list
         fxParamInfos.push_back(subscription);
         //std::cout <<"Registry::SubscribeParameter has subscribed for "<<fulldimname << std::endl;
         return true;
      }
   return false;




}// try

//catch(dabc::xd::Exception& e)
//   {
//      std::cout <<"SubscribeParameter could not find application prefix for node id :"<<remnode << std::endl;
//      return false;
//   }
catch(std::exception& e)
   {
          std::cout <<"SubscribeParameter std exception "<<e.what()<<" for name:"<<fulldimname <<std::endl;
          return false;
   }
catch(...)
   {
      std::cout <<"SubscribeParameter Unexpected exception for name:"<<fulldimname << std::endl;
      return false;
   }






}

bool dabc::xd::Registry::UnsubscribeParameter(dabc::Parameter* par)
{
if(par==0) return false;
bool result=false;
DimParameterInfo* delinfo=0;
{ // begin lockguard
LockGuard g(mainMutex_);
   std::vector<DimParameterInfo*>::iterator iter;
   for(iter=fxParamInfos.begin(); iter!=fxParamInfos.end(); ++iter)
      {
         DimParameterInfo* pinfo=*iter;
         try
            {
               if(pinfo->HasParameter(par))
                  {
                     //std::cout <<"Unsubscribe parameter "<< par->GetName()<<", pointer="<<par << std::endl;
                     fxParamInfos.erase(iter);
                     result=true;
                     delinfo=pinfo; // delete after lockguard because of possible conflicts with dim mutex
                     break;
                  }
            }
         catch(std::exception &e)
            {
               LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to UnsubscribeParameter  %s with standard exception: %s ",par->GetName(), e.what()));
               continue;
            }
         catch(...)
            {
               LOG4CPLUS_WARN(GetApplicationLogger(), toolbox::toString("dabc::xd::Registry failed to UnsubscribeParameter %s with unknown exception!\n",par->GetName()));
               continue;
            }
      }// for
} // end lockguard
delete delinfo;
return result;

}








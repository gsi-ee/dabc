/* Generated by Together */

#ifndef DABC_XD_NODE_H
#define DABC_XD_NODE_H
#include "DABCApplication.h"

#define _DABC_COMMAND_MANAGER_ "ManagerCommand"
// special command to wrap remote manager commands


#include "dabc/Manager.h"
#include "dabc/Command.h"

//extern "C" void InitUserPlugin(dabc::Manager* mgr);

namespace dabc{
namespace xd{

class Manager;

/**
*    This class defines a general application of a dabc node
*    By subclassing, we may set up different roles for the node
*    (e.g. worker, controller, readout, eventfilter)
    */
class Node : public dabc::xd::Application {

friend class dabc::xd::Manager;

public:




    Node(xdaq::ApplicationStub* as) throw (xdaq::exception::Exception);;


	virtual ~Node();



protected:

         /** Initialize core framework and module manager*/
    void InitManager();


 /** access to module/object manager */
   dabc::xd::Manager* Manager(){ return fxModMan;}


     /**
	*  Execute a command. Adds manager specific commands to superclass method.
	*/
    virtual void ExecuteLocalCommand(const std::string& com, const std::string& par);


   /** trigger state transition from core.
      * command object com is used to notify originator when
      * the state transition is complete (done asynchronously in UpdateState)*/
    bool InvokeStateTransition(const char* state_transition_name, dabc::Command* cmd=0);


      /** Update state record */
    virtual void UpdateState();

   /** Shutdown (exit) this application. Will terminate process if there is no other app running.*/
    virtual void Shutdown();



    /** Reply most recent core state change command.
      * If state transition was triggered by core only.*/
    void NotifyStateChangeDone();


    virtual void DoConfigure(toolbox::Event::Reference e) ;

	virtual void DoEnable(toolbox::Event::Reference e) ;

	virtual void DoHalt(toolbox::Event::Reference e) ;

    virtual void DoStop(toolbox::Event::Reference e) ;

	virtual void DoStart(toolbox::Event::Reference e) ;

	virtual void DoError(toolbox::Event::Reference e) ;

    virtual void DoHandleFailure(toolbox::Event::Reference e);

    virtual void DoResetFailure(toolbox::Event::Reference e);



    /** Execute command string par on local module */
    void ExecuteManagerCommand(std::string parameter);

      /** Send core command to remote manager. */
    bool SendManagerCommand(std::string managername, std::string parameter, bool async);




     /** get number of all active nodes in cluster.
	  * note that controller nodes are only accounted if they
	  * have global data flow controller*/
    int NumberOfAllNodes();

    /** get node id (instance of module application) from manager nodename.
      * returns <0 in case of error.*/
    int FindNodeID(std::string managername);

   /** find modules manager node name from instance number (nodeid)*/
    std::string FindManagerName(unsigned int instance);

    /** Get Prefix for application of instance number (nodeid) in cluster namespace. */
    std::string FindApplicationPrefix(unsigned int instance) throw (dabc::xd::Exception);



   /** Check if application of id is really up and running*/
    virtual bool CheckApplicationActive(unsigned int instance);


  /** this instance id number as configured*/
    int GetLocalID(){return nodeId_;}


       /** node id for module manager*/
    xdata::UnsignedInteger nodeId_;

    /** xdaq application id for the worker nodes*/
    xdata::UnsignedInteger workerTid_;

     /** xdaq appliation id for the controller node*/
    xdata::UnsignedInteger controllerTid_;



private:

      /** object manager of the core; offers controls interface*/
   dabc::xd::Manager* fxModMan;

   /** Number of all nodes on cluster. This value is dynamically set
     * at init time */
   int fiNumAllNodes;

    /** remember last command from core that invoked state change.
     * to be used for asynchronous reply*/
   dabc::Command* fxStateChangeCommand;



};
} // end namespace xd
} // end namespace bnet
#endif //BNETWORKER_H

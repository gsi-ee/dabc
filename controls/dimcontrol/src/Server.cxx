/********************************************************************
 * The Data Acquisition Backbone Core (DABC)
 ********************************************************************
 * Copyright (C) 2009- 
 * GSI Helmholtzzentrum fuer Schwerionenforschung GmbH 
 * Planckstr. 1
 * 64291 Darmstadt
 * Germany
 * Contact:  http://dabc.gsi.de
 ********************************************************************
 * This software can be used under the GPL license agreements as stated
 * in LICENSE.txt file which is part of the distribution.
 ********************************************************************/
/* Generated by Together */

#include "dimc/Server.h"
#include "dimc/Registry.h"

#include "dabc/logging.h"
#include "dabc/string.h"

dimc::Server* dimc::Server::gInstance=0;

dabc::Mutex dimc::Server::gGlobalMutex(true);

dimc::Server::Server():fOwner(0),fIsStarted(false)
{
DimServer::addClientExitHandler(this);
DimServer::addExitHandler(this);
DimServer::addErrorHandler(this);
DimServer::autoStartOff(); // avoid problems with concurrent update/registering before dimserver start
}

dimc::Server::~Server()
{
}

dimc::Server* dimc::Server::Instance()
{
// need static mutex here to avoid double creation of server by access glitch
dabc::LockGuard g(&gGlobalMutex);
   if(gInstance==0)
      gInstance=new dimc::Server();
return gInstance;
}

void dimc::Server::Delete()
{
// need static mutex here to avoid double deletion
dabc::LockGuard g(&gGlobalMutex);
if(gInstance!=0)
   {
      delete gInstance;
      gInstance=0;
   }
}

void dimc::Server::Start(std::string name, std::string dnsnode, unsigned int dnsport)
{
if(fIsStarted) return;
if(dnsport!=0)
   {
      DimServer::setDnsNode ( dnsnode.c_str(), dnsport);
      DOUT0(("Starting DIM server of name %s for dns %s:%d",name.c_str(),dnsnode.c_str(),dnsport));
   }
 else
   {
      DOUT0(("Starting DIM server of name %s for DIM_DNS_NODE  %s:%d",name.c_str(),DimServer::getDnsNode(),DimServer::getDnsPort()));
   }
DimServer::start(name.c_str());
DimServer::autoStartOn(); // any new service will be started afterwards
fIsStarted=true;
}



void dimc::Server::Stop()
{
if(fIsStarted)
   {
   ::DimServer::stop();
   fIsStarted=false;
   }
}




void dimc::Server::commandHandler()
{
   ::DimCommand* com = getCommand();
   if(com==0)
      {
         DOUT1(("NEVER COME HERE: dabc::Server::commandHandler() zero command"));
         return;
      }
   if(fOwner) fOwner->HandleDIMCommand(com);
}

void dimc::Server::errorHandler(int severity, int code, char *msg)
{
   if(fOwner) fOwner->OnErrorDIMServer(severity, code, msg);
}



void dimc::Server::clientExitHandler()
{
   if(fOwner) fOwner->OnExitDIMClient(getClientName());
}

void dimc::Server::exitHandler( int code )
{
   if(fOwner) fOwner->OnExitDIMServer(code);
}


///////////////////////////////////////////////////////////////////
//// Service entry
///////////////////////////////////////////////////////////////////

dimc::ServiceEntry::ServiceEntry(dabc::Parameter *parameter, const std::string& dimname)
   :  fPar(parameter), fService(0), fParser(dimname.c_str()), fStringbuffer(0)
{
if(fPar)
   {
      // create dim service here with reference to parameter data field
      // test here for string service:
      if(dynamic_cast<dabc::StrParameter*>(fPar))
         {
            fStringbuffer=new char[DIMC_STRINGBUFSIZE];
            fService=new DimService (dimname.c_str(), (char*) fStringbuffer);
            SetType(dimc::nameParser::ATOMIC);
         }
      else if(dynamic_cast<dabc::IntParameter*>(fPar))
         {
            fService=new DimService (dimname.c_str(), *((int*)fPar->GetPtr()));
            SetType(dimc::nameParser::ATOMIC);
         }
      else if(dynamic_cast<dabc::DoubleParameter*>(fPar))
         {
            fService=new DimService (dimname.c_str(), *((double*) fPar->GetPtr()));
            SetType(dimc::nameParser::ATOMIC);
         }
      else if(dynamic_cast<dabc::RateParameter*>(fPar))
         {
            int recsize=sizeof(dabc::RateRec);
            fService=new DimService (dimname.c_str(),const_cast<char*>(dabc::RateRecDesc), fPar->GetPtr(),recsize);
            SetType(dimc::nameParser::RATE);
         }
      else if(dynamic_cast<dabc::StatusParameter*>(fPar))
         {
            int recsize=sizeof(dabc::StatusRec);
            fService=new DimService (dimname.c_str(),const_cast<char*>(dabc::StatusRecDesc)  ,fPar->GetPtr(),recsize);
            SetType(dimc::nameParser::STATUS);
         }
      else if(dynamic_cast<dabc::InfoParameter*>(fPar))
         {
            int recsize=sizeof(dabc::InfoRec);
            fService=new DimService (dimname.c_str(),const_cast<char*>(dabc::InfoRecDesc)  ,fPar->GetPtr(),recsize);
            SetType(dimc::nameParser::INFO);
         }
      else if(dynamic_cast<dabc::HistogramParameter*>(fPar))
         {
            dabc::HistogramParameter* hpar=dynamic_cast<dabc::HistogramParameter*>(fPar);
            int chan=hpar->GetHistogramRec()->channels;
            int recsize=sizeof(dabc::HistogramRec) -sizeof(int) + chan*sizeof(int);
            std::string hformat=std::string(dabc::HistogramRecDesc) + FORMAT((":%d",chan));
            fService=new DimService (dimname.c_str(),const_cast<char*>(hformat.c_str()), fPar->GetPtr(),recsize);
            SetType(dimc::nameParser::HISTOGRAM);
         }
      else
         {
            DOUT1(("DimServiceEntry %s Initialization Error: unknown parameter kind %d", dimname.c_str(), fPar->Kind()));
         }
      Update();
   }


}


dimc::ServiceEntry::ServiceEntry(const std::string& data, const std::string& dimname)
   :  fPar(0), fService(0), fParser(dimname.c_str()), fStringbuffer(0)
{
   // for export of command descriptor: content will never be updated afterwards!
   fStringbuffer=new char[DIMC_STRINGBUFSIZE];
   strncpy(fStringbuffer, data.c_str(),DIMC_STRINGBUFSIZE);
   fService=new DimService (dimname.c_str(), (char*) fStringbuffer);
   SetType(dimc::nameParser::ATOMIC);
   Update();
}


dimc::ServiceEntry::~ServiceEntry()
{
      delete fService;
      delete [] fStringbuffer;
}

void dimc::ServiceEntry::Update()
{
   if(fService)
      {
         if(dynamic_cast<dabc::StrParameter*>(fPar))
            {
               // special treatment for strings: location may change, use own buffer here for DIM
               strncpy(fStringbuffer, fPar->GetStr().c_str(),DIMC_STRINGBUFSIZE);
               fService->updateService(fStringbuffer);
            }
         else
            {
               fService->updateService();
            }
      }

}

const std::string dimc::ServiceEntry::Name()
{
   std::string rev;
   if(fService) return rev=fService->getName();
   return rev;
}



void dimc::ServiceEntry::SetValue(const std::string val)
{
if(fParser.isChangable())
   {
      fPar->InvokeChange(val.c_str());
      DOUT1(("DimServiceEntry %s is changed to %s", Name().c_str(), val.c_str()));
      Update();
   }
else
   {
      EOUT(("DimServiceEntry %s tried change to %s, but not allowed!", Name().c_str(), val.c_str()));
   }
}

void dimc::ServiceEntry::SetType(dimc::nameParser::recordtype t)
{
   fParser.setType(t);
   if(fService)
      fService->setQuality(fParser.getQuality());
}

dimc::nameParser::recordtype dimc::ServiceEntry::GetType()
{
   return (fParser.getType());
}

void dimc::ServiceEntry::SetVisibility(dimc::nameParser::visiblemask mask)
{
   fParser.setVisibility(mask);
   if(fService)
      fService->setQuality(fParser.getQuality());
}

dimc::nameParser::visiblemask dimc::ServiceEntry::GetVisibility()
{
   return fParser.getVisibility();
}

void dimc::ServiceEntry::SetStatus(dimc::nameParser::recordstat s)
{
   fParser.setStatus(s);
   if(fService)
      fService->setQuality(fParser.getQuality());
}

dimc::nameParser::recordstat dimc::ServiceEntry::GetStatus()
{
   return fParser.getStatus();
}

dimc::nameParser::recordmode dimc::ServiceEntry::GetMode()
{
   return fParser.getMode();
}

void dimc::ServiceEntry::SetMode(dimc::nameParser::recordmode m)
{
fParser.setMode(m);
if(fService)
   fService->setQuality(fParser.getQuality());
}


///////////////////////////////////////////////////////////////////
//// ParameterInfo
///////////////////////////////////////////////////////////////////

void dimc::ParameterInfo::infoHandler( )
{
   // keep debug part
   // time_t time;
   // time = getTimestamp();
   //std::cout << "ParameterInfo "<<getName()<<"(type="<<fiType<<") received int=" << getInt() << " Time Stamp=" << ctime(&time) << "Quality="<< getQuality() << std::endl;
   // call parameter update depending on service type:
   switch (fiType) {
      case INTEGER:
          fxPar->InvokeChange(FORMAT(("%d",getInt())));
          break;
      case FLOAT:
          fxPar->InvokeChange(FORMAT(("%f",getFloat())));
          break;
      case DOUBLE:
          fxPar->InvokeChange(FORMAT(("%e",getDouble())));
          break;
      case SHORT:
           fxPar->InvokeChange(FORMAT(("%d",getShort())));
          break;
      case LONGLONG:
           fxPar->InvokeChange(FORMAT(("%ld",getLonglong())));
          break;
      case STRING:
          fxPar->InvokeChange(getString());
          break;
      case STRUCTURE:
          fxPar->InvokeChange((char*) getData()); // need method which also uses getSize
          break;
      case NONE:
      default:
          EOUT(("Never come here: ParameterInfo  with no type= %d", fiType));
          break;
   };
}

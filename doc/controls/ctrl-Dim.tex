\section{Dim Introduction}
 
DIM is a light weight communication protocoll based on publish/subscribe mechanism. Servers publish named services (commands or parameters) to a DIM name server. Clients can subscribe such services by name. They then get the values of the services subscribed from the server providing it. Whenever a server updates a service, all subscribed clients get the new value. Clients can also execute commands on the server side.

DIM provides the possibility to specify parameters and command arguments as primitives (I or L,X,C,F,D) or structures. The structures are described in a format string which can be retrieved by the clients (for parameters and commands) and servers (for commands):
\begin{verbatim}
   T:s;T:s;T:s ...
\end{verbatim}
Thus a client can generically access parameter structures, but without semantical interpretation.
In addition to the data and format string one longword called quality is sent.

\subsubsection{DIM naming conventions}
When the number and kind of services of DIM servers often change it would be very convenient if a generic GUI would show all available services without further programming. It would be also very nice if standard graphical elements would be used to display certain parameters like rate meters. If we have many services it would be convenient to have a naming convention which allows to build tree structures on the GUI.

Naming conventions for generic GUI:
\begin{verbatim}
   /servernamespace
   /nodename[:nodeID]
   /[[applicationnamespace::]applicationname:]applicationID
   /[TYPE.module.]name
   
   /DABC/lx05/Control/RunState
\end{verbatim}

We recommend to forbid spaces in any name fields. Dots should not be used except in names (last field). The generic GUI can handle only services from one servernamespace. For DABC and MBS this servernamespace is set to DABC.

\subsubsection{DIM records}
For generic GUIs we need something similar to the EPICS records. This means to define structures which can be identified. How shall they be indentified? One possibility would be to prefix a type to the parameter name, i.e. {\\tt rate:DataRate}. Another to use the quality longword. This longword can be set by the server. One could mask the bytes of this longword for different information:
\begin{verbatim}
   mode (MSB)| visibility | type | status (LSB)
   mode: not used
   visibility: Bit wise (can be ORed)
     HIDDEN    = all zero
     VISIBLE   = 1  appears in parameter table
     MONITOR   = 2  in table, graphics shown automatically 
     			if type is STATUS, RATE or HISTOGRAM
     CHANGABLE = 4  in table, can be modified
     IMPORTANT = 8  in table also if GUI has a "minimal" view.
   type: (exclusive)
     PLAIN     = 0
     GENERIC   = 1
     STATE     = 2
     RATE      = 3
     HISTOGRAM = 4
     MODULE    = 5
     PORT      = 6
     DEVICE    = 7
     QUEUE     = 8
     COMMANDDESC= 9
     INFO      = 10
   status: (exclusive) 
     NOTSPEC     = 0
     SUCCESS     = 1
     INFORMATION = 2
     WARNING     = 3
     ERROR       = 4
     FATAL       = 5
\end{verbatim}

Then we could provide at the client side objects for handling and visualization of such records.

\subsubsection{Record ID=0: Plain}

Scalar data item of atomic type

\subsubsection{Record ID=1: Generic self describing}
For these one would need one structure per number of arguments. Therefore the generic type would be rather realized by a more flexible text format, like XML. This means the DIM service has a string as argument which must be parsed to get the values.
\begin{compactdesc}
\item[XML schema] char, similar to command descriptor.
\item[Format:] C
\end{compactdesc}

\subsubsection{Record ID=2: State}
\begin{compactdesc}
\item[severity] int, 0=Success, 1=warning, 2=error, 3=fatal)
\item[color] char, (Red, Green, Blue, Cyan, Magenta, Yellow)
\item[state] char, name of state
\item[Format:] L:1;C:16;C:16
\end{compactdesc}

\subsubsection{Record ID=3: Rate}
\begin{compactdesc}
\item[value]   float 
\item[displaymode ]   int, (arc, bar, statistics, trend)
\item[lower limit]   float 
\item[upper limit]   float 
\item[lower alarm]   float
\item[upper alarm]   float 
\item[color]   char,  (Red, Green, Blue, Cyan, Magenta, Yellow)
\item[alarm color]   char,  (Red, Green, Blue, Cyan, Magenta, Yellow)
\item[units]   char 
\item[Format:] F:1;L:1;F:1;F:1;F:1;F:1;C:16;C:16;C
\end{compactdesc}

\subsubsection{Record ID=4: Histogram}
Structure must be allocated including the data field witch may be integer or double.
\begin{compactdesc}
\item[channels]   int 
\item[lower limit]   float 
\item[upper limit]   float 
\item[axis lettering]   char 
\item[content lettering]   char 
\item[color]   char, (White, Red, Green, Blue, Cyan, Magenta, Yellow)
\item[first data channel]   int 
\item[Format:] L:1;F:1;F:1;C:32;C:32;C:16;I(or D)
\end{compactdesc}

\subsubsection{Record ID=10: Info}
\begin{compactdesc}
\item[verbose]   int,  (0=Plain text, 1=Node:text)
\item[color]   char,  (Red, Green, Blue, Cyan, Magenta, Yellow)
\item[text]   char,  line of text
\item[Format:] L:1;C:16;C:128
\end{compactdesc}

\subsubsection{Record ID=9: Command descriptor}
This is an invisible parameter describing a command argument list. The service name must be correlated with the command name, e.g. by trailing underscore.
\begin{compactdesc}
\item[description]   char,  XMl string describing arguments
\item[Format:] C
\end{compactdesc}

The descriptor string could be XML specifying the argument name, type, required and description. Question if default value should be given here for optional arguments. Example:
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<command name="com1" scope="public" content="default">
<argument name="arg1" type="F" value="1.0" required="req"/>
<argument name="arg2" type="I" value="2" required="opt"/>
<argument name="arg3" type="C" value="def3" required="req"/>
<argument name="arg4" type="boolean" value="" required="opt"/>
</command>
\end{verbatim}

The command definition can be used by the GUI to build input panels for commands. The scope can be used to classify commands, content should be set to default if argument values are default, values if argument values have been changed.
\subsubsection{Commands}
Commands have one string argument only. This leaves the arguments to semantic definitions in string format. To implement a minimal security, the first 14 characters of the argument string should be an encrypted password (13 characters by crypt plus space). The arguments are passed as string. A command structure could look like:

\begin{compactdesc}
\item[password]   char[14]
\item[argument]   char,  string
\item[Format:] C
\end{compactdesc}

The argument string has the same XML as the command description. Thus, the same parser can be used to encode/decode the description (parameter) and the command. An alternate format is the MBS style format argument = value where boolean arguments are given by -argument if argument is true.
Setting parameters
If a parameter should be changable from the GUI, there must be a command for that. A fixed command SetParameter must be defined on the server for that. Argument is a string of form name=value. In the parameter table of the GUI one field can be provided to enter a new value and the command SetParameter is used to set the new value.


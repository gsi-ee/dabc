[user/user-exa-mbs.tex]
\section{Example \mbs~ event building}
\subsection{\mbs~ upgrade for \dabc}
To have minimal changes, we use standard collector and transport. Two changes:
\subsubsection{Increased buffer size support}
This is done in a completely compatible way. The only problem is the 16 bit {\tt i\_used field} in the buffer header keeping the number of 16 bit data words (behind buffer header). With a new rule we store this number in 32 bit field {\tt l\_free[2]}. Only if dlen is less equal {\tt MAX\_\_DLEN} defined as {\tt (16K-sizeof(bufhe))/2} this number is also stored in {\tt i\_used} as before. Modifications have to be made in all \mbs~ modules accessing {\tt i\_used}. Modules outside \mbs~ can be modified on demand to support large buffers. Current buffers still can be handled without change.\\
When \mbs~ writes large buffer files only the used part of the file header is written. Number of 16 bit words behind buffer header structure is stored in {\tt filhe\_used}.
Event API f\_evt is updated to handle large buffers on input.
Note: By setup the number of buffers per stream can be set to one. This suppresses event spanning.
Large buffers can be used by standard \mbs.
\subsubsection{Variable sized buffers}
As a second step variable sized buffers are implemented. They get a new type 100. The allocated buffers are still fixed length as before. However, the \mbs~ transport would write only the used part of the buffers to clients. Processing these buffers a module must first read the header, then get the used size from {\tt iUsedWords} ({\tt free[2]}) and read the rest. Modules outside \mbs~ must be modified to process such buffers.
In \mbs, after stream buffers are created, buffer types are set to 100 by a new command {\tt enable dabc} in transport. This command also sets the transport synchronous mode. In this mode transport processes streams only if a client is connected.
\subsection{New LMD file format}
With \dabc~ as event builder for \mbs~ there is no need to write files in \mbs. This gives more freedom to design a new file format. This format will be written by \dabc~ and read by {\tt fLmd} functions (get event). The format is quite simpler than the old one, because it has no buffer structure causing so much complications by event spanning.

A file has a file header as before, but with a fixed size and a variable part (size {\tt iUsedWords}).
Behind the header follow data elements with {\tt sMbsHeader} headers (length, type, subtype) allowing to identify and process or skip them. Besides event data, time stamps may be inserted from the original \mbs~ formatted buffers to preserve this time information. Writing/reading such a file is very straight forward. The file header contains the number of data elements and the maximum size of elements. This information is collected throughout the file writing and written on close into the file header. The file header is an {\tt sMbsFileHeader} structure.
{\tt iMaxWords} is the maximum size of elements,
{\tt iElements} is the number of data elements.

The file size is no longer restricted to 2GB. Optionally an element index is written at the end of the file. This allows for random access of elements in the file through this index table. The table itself has 32-bit values for the element offsets (in 32-bit). It can therefore address offsets up to 16GB in the file. If larger files are needed, the table can be created with 64-bit values giving unlimited addressing.

Note: This file format needs the rewind file function because the file header must be rewritten to store {\tt iMaxWords}, {\tt iElements}, and optionally the offset of the index table. This function is currently not implemented in the {\tt RFIO} package, but will be done.


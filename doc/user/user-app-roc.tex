[user/user-app-roc.tex]
\lsection[DABC as MBS data server]{user-app-mbs-eventserver}{\dabc\ as \mbs\ data server}
The use case here is that a single \dabc\ node should provide data in the \mbs\
event format on a server socket to be used by external analysis and monitoring
programs like Go4 \cite{go4web}. The event data can be simulated by a generator
module. A practical case is to read data from any front-ends and format it like \mbs\ events.
This method is used by the ROC readout.

For the random event generator, such set-up looks like this:
\begin{small}
\begin{verbatim}
<?xml version="1.0"?>
<dabc version="1">
  <Context host="lxi009" name="Server">
    <Run>
      <lib value="libDabcMbs.so"/>
      <func value="InitMbsGenerator"/>
    </Run>
    <Module name="Generator">
       <NumSubevents value="3"/>
       <FirstProcId value="77"/>
       <SubeventSize value="128"/>
       <Go4Random value="false"/>
       <BufferSize value="16384"/>
       <Port name="Output">
          <OutputQueueSize value="5"/>
          <MbsServerKind value="Stream"/>
          <MbsServerPort value="6006"/>
        </Port>
     </Module>
  </Context>
</dabc>
\end{verbatim}
\end{small}
There is only one \keyw{Context} node, specified by the nodename, with one
simple C function \func{InitMbsGenerator()} to run, and with one \keyw{Module}
that produces the event data as specified in its parameters. The data server
is specified by parameters of the \keyw{Output} \keyw{Port}: The tag
\keyw{MbsServerKind} can be \keyw{Stream} or \keyw{Transport} to emulate either variant
of the standard \mbs\ server sockets. A complete description of this example
can be found in Programmer Manual section \paref{exa_mbs_eventsgenerator}. 
The setup files for standard \mbs\ use cases can be found in directory
\begin{verbatim}
$DABCSYS/applications/mbs
\end{verbatim}

\lsection{user:roc}{ROC event building}
A more practical use case is to prepare data as \mbs\ events that was
read by \dabc\ from external front-end hardware. This is shown with the
setup-file for the readout controller ROC example
(see the full description of this example in Programmer Manual chapter \paref{prog-exa-roc}):

\begin{small}
\begin{verbatim}
<?xml version="1.0"?>
<dabc version="1">
<Context name="Readout">
  <Run>
    <lib value="libDabcMbs.so"/>
    <lib value="libDabcKnut.so"/>
    <logfile value="Readout.log"/>
  </Run>
  <Application class="roc::Readout">
    <DoCalibr value="0"/>
    <NumRocs value="3"/>
    <RocIp0 value="cbmtest01"/>
    <RocIp1 value="cbmtest02"/>
    <RocIp2 value="cbmtest04"/>
    <BufferSize value="65536"/>
    <NumBuffers value="100"/>
    <TransportWindow value="30"/>
    <RawFile value="run090.lmd"/>
    <MbsServerKind value="Stream"/>
    <MbsFileSizeLimit value="110"/>
  </Application>
 </Context>
</dabc>
\end{verbatim}
\end{small}

Here the parameters are defined for the \keyw{<Application>} instance
"roc::Readout" that controls  the readout of 3 {\em ROC} nodes via UDP, 
and combines the data into one \mbs\ event by means of some internal
\class{Modules}. Hence there is no simple
run function as before, the \dabc\ runtime environment will call
appropriate methods of the \class{Application} to configure and run
the set-up. Note that in this case the \mbs\ data is not only provided to a
stream server as defined in \keyw{<MbsServerKind>}, but is also
written to a {\tt *.lmd} (list mode data) file which can be specified
in application parameter \keyw{<RawFile>}.

Both single node examples above do not require to be launched from the \dabc\ GUI (although this is possible and may be useful to monitor the data rates and actual parameters).
They can be started directly from a shell 
by calling the standard \func{dabc\_run}
executable with the configuration file name as argument:
\verba{dabc\_run Readout.xml}. 
This executable will load the specified libraries,
create the application, configure it, and switch the system in 
the \keyw{Running} state.   


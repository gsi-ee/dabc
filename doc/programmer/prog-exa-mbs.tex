[programmer/prog-exa-mbs.tex]

\section{Overview}

MBS (Multi Branch System) is standard DAQ system of GSI.
Support of MBS in DABC includes several components:
\bbul
\item type definitions for different MBS structures  
\item iterator classes for reading/creating MBS event/subevent data 
\item support of new LMD file format  
\item \class{mbs::ClientTransport} for connecting to MBS servers  
\item \class{mbs::ServerTransport} to "emulate" running MBS servers  
\item \class{mbs::CombinerModule} for performing mbs events building   
\item \class{mbs::GeneratorModule} for generating random mbs events 
\ebul

This plugin is part of standard DABC distribution.  
All sources can be found in \$DABCSYS/plugin/mbs directory.
All these sources compiled into library libDabcMbs.so, which is placed in \$DABCSYS/lib. 

\section{Events iterators}

MBS defines own event/subevent structures. To access such events data,
number of structures are defined in "mbs/LmdTypeDefs.h" and "mbs/MbsTypeDefs.h".
In first file structure \class{mbs::Header} is defined, which is just container for 
arbitrary raw data. Such container is used to store/read data from LMD files.
In "mbs/MbsTypeDefs.h" file following structures are defined:
\bbul
\item \class{mbs::EventHeader} - MBS event header of 10-1 type 
\item \class{mbs::SubeventHeader} - MBS subevent header of 10-1 type 
\ebul
DABC operates with buffer (type \keyw{mbt\_MbsEvents}), where several subsequent 
MBS events (there is no buffer header in front!). To iterate over all events in such
buffer class \class{mbs::ReadIterator} was designed (defined in "mbs/Iterator.h"). It provides
possibility to iterate (access) over all events in buffer in following way:

\begin{small}
\begin{verbatim}
#include "mbs/Iterator.h"

void Print(dabc::Buffer* buf)
{
   mbs::ReadIterator iter(buf);
   while (iter.NextEvent()) {
      DOUT1(("Event %u size %u", 
              iter.evnt()->EventNumber(), 
              iter.evnt()->FullSize()));
      while (iter.NextSubEvent()) {
         DOUT1(("Subevent crate %u procid %u size %u",
               iter.subevnt()->iSubcrate, 
               iter.subevnt()->iProcId, 
               iter.subevnt()->FullSize()));
      }
   }
}
\end{verbatim}
\end{small}

Another class \class{mbs::WriteIterator} is developed to fill number  
of MBS events into \class{dabc::Buffer}. Way to use this iterator 
illustrated by following code:

\begin{small}
\begin{verbatim}
#include "mbs/Iterator.h"

void Fill(dabc::Buffer* buf)
{
   mbs::WriteIterator iter(buf);
   unsigned evntid = 0;
   while (iter.NewEvent(evntid++)) {
      for (unsigned subcnt = 0; subcnt < 3; subcnt++) {
         if (!iter.NewSubevent(28, 0, subcnt)) return;
         // fill raw data iter.rawdata() here
         memset(iter.rawdata(), 0, 28);
         iter.FinishSubEvent(28);
      } 
      if (!iter.FinishEvent()) return;
   }
}
\end{verbatim}
\end{small}


\section{File I/O}

LMD file format used in MBS. There is class \class{mbs::LmdFile}, which provide
C++ interface for reading/writing such lmd file.

To use \class{mbs::LmdFile} as input/output transport of the module, classes \class{mbs::LmdInput} 
and \class{mbs::LmdOutput} were developed. 

In general case, to provide user-specific input/output capability over port, 
one should implement complete \class{dabc::Transport} interface, which includes 
event handling, queue organization, complex initialization sequence. 
All this necessary for cases like socket or InfiniBand transports, 
but too complicated for simple cases as file I/O. Therefore, special kind of
transport \class{dabc::DataIOTransport} was developed, which handle most of such complex tasks
and requires to implement relatively simple \class{dabc::DataInput} and
\class{dabc::DataOutput} interfaces.

Class \class{mbs::LmdOutput} inherits \class{dabc::DataOutput} and provides possibility to save 
MBS events, placed in \class{dabc::Buffer} objects, in LMD file. 
In addition to \class{mbs::LmdFile} functionality, it allows to create
multiple files when file size limit is exceeded. Class has following parameters:
\bbul
\item \param{MbsFileName}      - name of lmd file (including .lmd extension)  
\item \param{MbsFileSizeLimit} - size limit (in Mb) of single file, 0 - no limit
\ebul

Class \class{mbs::LmdInput} inherits \class{dabc::DataInput} and allows to read 
MBS events from LMD file(s) and provide them over input ports into module. 
It has following parameters:
\bbul
\item \param{MbsFileName} - name of lmd file (multicast symbols * and ? supported)  
\item \param{BufferSize}  - buffer size to read data
\ebul

\func{CreateDataInput} and \func{CreateDataOutput} methods were implemented in \class{mbs::Factory} class, 
that user can instantiate these classes using plugin meachanism of DABC. 
  

Here is an example, how output file for generator module can be configured:
   
\begin{small}
\begin{verbatim}
   ...
   dabc::mgr()->CreateModule("mbs::GeneratorModule", "Generator");
   dabc::Command* cmd = 
      new dabc::CmdCreateTransport("Generator/Output", mbs::typeLmdOutput);
   cmd->SetStr(mbs::xmlFileName, "output.lmd");
   cmd->SetInt(mbs::xmlSizeLimit, 100);
   dabc::mgr()->Execute(cmd);
   ...
\end{verbatim}
\end{small}
       
Here one first creates module and than configure (via command) type of
output transport and its parameters.        
       
Another example shows, how several input files can be configured for combiner:
   
\begin{small}
\begin{verbatim}
   ...
   dabc::Command* cmd = 
      new dabc::CmdCreateModule("mbs::CombinerModule", "Combiner");
   cmd->SetInt(dabc::xmlNumInputs, 3);
   dabc::mgr()->Execute(cmd);
   
   for (unisgned n=0;n++;n<3) {
      cmd = new dabc::CmdCreateTransport(
         FORMAT(("Combiner/Input%u",n)), mbs::typeLmdInput);
      cmd->SetStr(mbs::xmlFileName, FORMAT(("input%u_*.lmd",n)));
      dabc::mgr()->Execute(cmd);
   }   
   ...
\end{verbatim}
\end{small}

In this example one create module with 3 inputs and than for each input port lmd file transport is created.


\section{Socket classes}

All communication with MBS servers performed via socket. DABC has number
of class for socket handling, included in base package (libDabcBase.so).
Main idea of these classes is to handle socket operations (creation, connection, sending, receiving and 
error handling) in form of event processing. 

Class \class{dabc::SocketThread} organises event loop, produced by sockets.
Each system socket assigned with instance of \class{dabc::SocketProcessor} class. 
Processing of socket events done in virtual methods
of class \class{dabc::SocketProcessor}, which has several subclasses for different 
kinds of sockets: 
\bbul
\item  - \class{dabc::SocketServerProcessor} - server socket for connection  
\item  - \class{dabc::SocketClientProcessor} - client socket for connection  
\item  - \class{dabc::SocketIOProcessor} - send/recv handling  
\ebul

One can use \class{dabc::SocketThread} together with other kind of processors
like module classes, but not wise-versa (one cannot use socket processors inside other
thread types). Therefore, it is possible to run module and all its
socket transports in one single thread if socket thread for such module created in
advance (see MBS generator example).
  

\section{Server transport}

Class \class{mbs::ServerTransport} was developed to provide MBS servers functionality in DABC.
Using this class one can emulate work of MBS transport server and MBS stream server. 
This is also good example for usage of \class{dabc::SocketProcessor} classes.

Implementation of \class{mbs::ServerTransport} based on generic class \class{dabc::Transport} and 
internally uses two kinds of sockets: socket for handling connection and I/O socket for 
sending data.
  
Server transport has following parameters:

\begin{tabular}{llll}
\hline
Name &  Type &  Dflt & Description  \\
\hline
\param{MbsServerKind} & str & Transport & kind of mbs server: "Transport" or "Stream" \\  
\param{MbsServerPort} & int & 6000 & server port number for socket connection \\
\hline
\end{tabular}

These parameters can be set in xml file like here:
\begin{small}
\begin{verbatim}
...
  <Module name="Generator">
    <Port name="Output">
      <MbsServerKind value="Transport"/>
      <MbsServerPort value="16020"/>
    </Port>
  </Module>
...
\end{verbatim}
\end{small}

Than, to create such transport, following code should be executed:
\begin{small}
\begin{verbatim}
  ...
  dabc::mgr()->CreateTransport("Generator/Output", 
                  mbs::typeServerTransport, "GeneratorThrd");
  ...
\end{verbatim}
\end{small}


Another possibility to specify these parameters - use \comm{dabc::CmdCreateTransport}:
\begin{small}
\begin{verbatim}
  ...
  dabc::Command* cmd = new dabc::CmdCreateTransport("Generator/Output", 
                         mbs::typeServerTransport, "MbsTransThrd");
  cmd->SetStr(mbs::xmlServerKind, mbs::ServerKindToStr(mbs::StreamServer));
  cmd->SetInt(mbs::xmlServerPort, mbs::DefualtServerPort(mbs::StreamServer) + 5);
  dabc::mgr()->Execute(cmd);
  ...
\end{verbatim}
\end{small}



\section{Client transport}

Class \class{mbs::ClientTransport} allows connect DABC with MBS. 
For the moment MBS transport and stream servers are supported.  

Client transport has following parameters:

\begin{tabular}{llll}
\hline
Name &  Type &  Dflt & Description  \\
\hline
\param{MbsServerKind} & str & Transport & kind of mbs server: "Transport" or "Stream" \\  
\param{MbsServerName} & str & localhost & host name where mbs server runs  \\
\param{MbsServerPort} & int & 6000 & server port number for socket connection \\
\hline
\end{tabular}



To create client connection, following pease of code should be used:

\begin{small}
\begin{verbatim}
  ...
  dabc::Command* cmd = new dabc::CmdCreateTransport("Combiner/Input0", 
                         mbs::typeClientTransport, "MbsTransThrd");
  cmd->SetStr(mbs::xmlServerKind, mbs::ServerKindToStr(mbs::StreamServer));
  cmd->SetStr(mbs::xmlServerName, "lxi010.gsi.de");
  cmd->SetInt(mbs::xmlServerPort, mbs::DefualtServerPort(mbs::StreamServer) + 5);
  dabc::mgr()->Execute(cmd);
  ...
\end{verbatim}
\end{small}

 

\section{Events generator}


Class \class{mbs::GeneratorModule} is an example of simple module design, 
which just fills buffers with random MBS 
events and provides them to the output. 
Schematically implementation of module can be shown as:

\begin{small}
\begin{verbatim}
#include "dabc/ModuleAsync.h"

class GeneratorModule : public dabc::ModuleAsync {
protected:
   dabc::PoolHandle*       fPool;
   dabc::BufferSize_t      fBufferSize;
public:
   GeneratorModule(const char* name, dabc::Command* cmd = 0) :
      dabc::ModuleAsync(name, cmd)
   {
      ...
      fBufferSize = GetCfgInt(dabc::xmlBufferSize, 16384, cmd);
      fPool = CreatePoolHandle("Pool", fBufferSize, 10);
      CreateOutput("Output", fPool, 5);
   }

   virtual void ProcessOutputEvent(dabc::Port* port)
   {
      dabc::Buffer* buf = fPool->TakeBuffer(fBufferSize);
      FillRandomBuffer(buf);
      port->Send(buf);
   }
};
\end{verbatim}
\end{small}

In module constructor pool handle create to declare that module requires
memory pool with 10 buffers of defined size. Buffer size here 
taken as configuration parameter. When output port is created, pool handle and
default queue size is specified.

The only virtual method which should be implemented for generator module is
\func{ProcessOutputEvent}. This function call every time when free space in port
output queue is appears. It means, when module starts, it immediately gets 
N times (size of output queue, here 5) this call while there is N empty places in the queue.
The only action here is take new buffer from memory pool, fill it with rundom
events and send to output.    

Real class \class{mbs::GeneratorModule} included in libDabcMbs.so library and has
following parameters:

\begin{tabular}{llll}
\hline
Name &  Type &  Dflt & Description  \\
\hline
\param{NumSubevents} & int & 2 &  number of subevents in generated event  \\   
\param{FirstProcId}  & int & 0 & value of procid field of first subevent \\
\param{SubeventSize} & int & 32  &  size of rawdata in subevent            \\
\param{Go4Random}    & bool & true & is raw data filled with random value  \\
\param{BufferSize}   & int & 16384 & server port number for socket connection \\
\hline
\end{tabular}
  
There is also \func{StartMbsGenerator} function to instantiate and run generator module.
It demonstrates, how thread of type \class{dabc::SocketThread} can be created
and used by both module and transport object. 
\begin{small}
\begin{verbatim}
extern "C" void StartMbsGenerator()
{
  dabc::mgr()->CreateThread("GenerThrd", dabc::typeSocketThread);
  dabc::mgr()->CreateModule("mbs::GeneratorModule", "Generator", "GenerThrd");
  dabc::mgr()->CreateTransport("Generator/Output", mbs::typeServerTransport, "GenerThrd");
  dabc::mgr()->StartModule("Generator");
}
\end{verbatim}
\end{small}

To run generator module with all default parameters, 
simple xml file should be used:   
\begin{small}
\begin{verbatim}
<?xml version="1.0"?>
<dabc version="1">
  <Context host="lxi009" name="Server">
    <Run>
      <lib value="libDabcMbs.so"/>
      <func value="StartMbsGenerator"/>
    </Run>
  </Context>
</dabc>
\end{verbatim}
\end{small}

One can also specify all module and transport parameters directly:
\begin{small}
\begin{verbatim}
<?xml version="1.0"?>
<dabc version="1">
  <Context host="lxi009" name="Server">
    <Run>
      <lib value="libDabcMbs.so"/>
      <func value="StartMbsGenerator"/>
    </Run>
    <Module name="Generator">
       <NumSubevents value="3"/>
       <FirstProcId value="77"/>
       <SubeventSize value="128"/>
       <Go4Random value="false"/>
       <BufferSize value="16384"/>
       <Port name="Output">
          <OutputQueueSize value="5"/>
          <MbsServerKind value="Stream"/>
          <MbsServerPort value="6006"/>
        </Port>
     </Module>
  </Context>
</dabc>
\end{verbatim}
\end{small}

There is example \$DABCSYS/application/mbs/GeneratorTest.xml file,  
which demonstrate  usage of generator module. 


\section{MBS event building}
Class \class{mbs::CombinerModule} provides possibility to combine events from
several running MBS systems. It has following parameters:

\begin{tabular}{llll}
\hline
Name &  Type &  Dflt & Description  \\
\hline
\param{BufferSize}   & int & 16384 & server port number for socket connection \\
\param{NumInputs}    & int & 2 &  number of mbs data sources  \\   
\param{DoFile}       & bool & false & create LMD file store for combined events \\
\param{DoServer}     & bool & false  &  create MBS server to provide data further   \\
\hline
\end{tabular}


There is function \func{StartMbsCombiner}, which initialized combiner module and starts
data taking. There is \$DABCSYS/applications/mbs/Combiner.xml example xml file: 

\begin{small}
\begin{verbatim}
<?xml version="1.0"?>
<dabc version="1">
  <Context host="localhost" name="Combiner">
    <Run>
      <lib value="libDabcMbs.so"/>
      <func value="StartMbsCombiner"/>
      <logfile value="combiner.log"/>
    </Run>
    <Module name="Combiner">
       <NumInputs value="3"/>
       <DoFile value="false"/>
       <DoServer value="true"/>
       <BufferSize value="16384"/>
       <Port name="Input0">
          <InputQueueSize value="5"/>
          <MbsServerKind value="Transport"/>
          <MbsServerName value="lxi009"/>
          <MbsServerPort value="6000"/>
       </Port>
       <Port name="Input1">
          <InputQueueSize value="5"/>
          <MbsServerKind value="Transport"/>
          <MbsServerName value="lxi010"/>
          <MbsServerPort value="6000"/>
       </Port>
       <Port name="Input2">
          <InputQueueSize value="5"/>
          <MbsServerKind value="Transport"/>
          <MbsServerName value="lxi011"/>
          <MbsServerPort value="6000"/>
       </Port>
       <Port name="FileOutput">
          <OutputQueueSize value="5"/>
          <MbsFileName value="combiner.lmd"/>
          <MbsFileSizeLimit value="128"/>
        </Port>
       <Port name="ServerOutput">
          <OutputQueueSize value="5"/>
          <MbsServerKind value="Stream"/>
        </Port>
     </Module>
  </Context>
</dabc>
\end{verbatim}
\end{small}




[programmer/prog-exa-mbs.tex]

\section{Overview}

MBS (Multi Branch System) is standard DAQ system of GSI.
Support of MBS in DABC includes several components:
\bbul
\item type definitions for different MBS structures  
\item iterator classes for reading/creating MBS event/subevent data 
\item support of new LMD file format  
\item \class{mbs::ClientTransport} for connecting to MBS servers  
\item \class{mbs::ServerTransport} to "emulate" running MBS servers  
\item \class{mbs::CombinerModule} for performing mbs events building   
\item \class{mbs::GeneratorModule} for generating random mbs events 
\ebul

This plugin is part of standard DABC distribution.  
All sources can be found in \$DABCSYS/plugin/mbs directory.
All these sources compiled into library libDabcMbs.so, which is placed in \$DABCSYS/lib. 

\section{Events iterators}

MBS defines own event/subevent structures. To access such events data,
number of structures are defined in "mbs/LmdTypeDefs.h" and "mbs/MbsTypeDefs.h".
In first file structure \class{mbs::Header} is defined, which is just container for 
arbitrary raw data. Such container is used to store/read data from LMD files.
In "mbs/MbsTypeDefs.h" file following structures are defined:
\bbul
\item \class{mbs::EventHeader} - MBS event header of 10-1 type 
\item \class{mbs::SubeventHeader} - MBS subevent header of 10-1 type 
\ebul
DABC operates with buffer (type \keyw{mbt\_MbsEvents}), where several subsequent 
MBS events (there is no buffer header in front!). To iterate over all events in such
buffer class \class{mbs::ReadIterator} was designed (defined in "mbs/Iterator.h"). It provides
possibility to iterate (access) over all events in buffer in following way:

\begin{verbatim}
#include "mbs/Iterator.h"

void Print(dabc::Buffer* buf)
{
   mbs::ReadIterator iter(buf);
   while (iter.NextEvent()) {
      DOUT1(("Event %u size %u", 
              iter.evnt()->EventNumber(), 
              iter.evnt()->FullSize()));
      while (iter.NextSubEvent()) {
         DOUT1(("Subevent crate %u procid %u size %u",
               iter.subevnt()->iSubcrate, 
               iter.subevnt()->iProcId, 
               iter.subevnt()->FullSize()));
      }
   }
}
\end{verbatim}

Another class \class{mbs::WriteIterator} is developed to fill number  
of MBS events into \class{dabc::Buffer}. Way to use this iterator 
illustrated by following code:

\begin{verbatim}
#include "mbs/Iterator.h"

void Fill(dabc::Buffer* buf)
{
   mbs::WriteIterator iter(buf);
   unsigned evntid = 0;
   while (iter.NewEvent(evntid++)) {
      for (unsigned subcnt = 0; subcnt < 3; subcnt++) {
         if (!iter.NewSubevent(28, 0, subcnt)) return;
         // fill raw data iter.rawdata() here
         memset(iter.rawdata(), 0, 28);
         iter.FinishSubEvent(28);
      } 
      if (!iter.FinishEvent()) return;
   }
}
\end{verbatim}


\section{File I/O}

LMD file format used in MBS. There is class \class{mbs::LmdFile}, which provide
C++ interface for reading/writing such lmd file.

To use \class{mbs::LmdFile} as input/output transport of the module, classes \class{mbs::LmdInput} 
and \class{mbs::LmdOutput} were developed. 

In general case, to provide user-specific input/output capability over port, 
one should implement complete \class{dabc::Transport} interface, which includes 
event handling, queue organization, complex initialization sequence. 
All this required for cases like socket or InfiniBand transports, 
but maybe too complicated for simple cases as file I/O. Therefore, special kind of
transport \class{dabc::DataIOTransport} was developed, which handle most of such complex tasks
and only requires to implement relatively simple \class{dabc::DataInput} and
\class{dabc::DataOutput} interfaces.

Class \class{mbs::LmdOutput} inherits \class{dabc::DataOutput} and provides possibility to save 
MBS events, placed in \class{dabc::Buffer} objects, in LMD file. 
In addition to \class{mbs::LmdFile} functionality, it allows to create
multiple files when file size limit is exceeded. Following parameters are supported:
\bbul
\item \param{MbsFileName}      - name of lmd file (including .lmd extension)  
\item \param{MbsFileSizeLimit} - size limit (in Mb) of single file, 0 - no limit
\ebul

Class \class{mbs::LmdInput} inherits \class{dabc::DataInput} and allows to read 
MBS events from LMD file(s) and provide them over input ports into module.

It has following parameters:
\bbul
\item \param{MbsFileName} - name of lmd file (multicast symbols * and ? supported)  
\item \param{BufferSize}  - buffer size to read data
\ebul

\func{CreateDataInput} and \func{CreateDataOutput} methods were implemented in \class{mbs::Factory} class, 
that user can instantiate these classes using plugin meachanism of DABC. 
  

Here is an example, how output file for generator module can be configured:
   
\begin{verbatim}
   ...
   dabc::mgr()->CreateModule("mbs::GeneratorModule", "Generator");
   dabc::Command* cmd = 
      new dabc::CmdCreateTransport("Generator/Output", mbs::typeLmdOutput);
   cmd->SetStr(mbs::xmlFileName, "output.lmd");
   cmd->SetInt(mbs::xmlSizeLimit, 100);
   dabc::mgr()->Execute(cmd);
   ...
\end{verbatim}
       
Here one first creates module and than configure (via command) type of
output transport and its parameters.        
       
Another example shows, how several input files can be configured for combiner:
   
\begin{verbatim}
   ...
   dabc::Command* cmd = 
      new dabc::CmdCreateModule("mbs::CombinerModule", "Combiner");
   cmd->SetInt(dabc::xmlNumInputs, 3);
   dabc::mgr()->Execute(cmd);
   
   for (unisgned n=0;n++;n<3) {
      cmd = new dabc::CmdCreateTransport(
         FORMAT(("Combiner/Input%u",n)), mbs::typeLmdInput);
      cmd->SetStr(mbs::xmlFileName, FORMAT(("input%u_*.lmd",n)));
      dabc::mgr()->Execute(cmd);
   }   
   ...
\end{verbatim}

In this example one create module with 3 inputs and than for each input port lmd file transport is created.


\section{Socket classes}

All communication with MBS servers performed via socket. DABC has number
of class for socket handling, included in base package (libDabcBase.so).
Main idea of these classes is to handle socket operation (creation, connection, sending, receiving and 
error handling) in form of event processing. 

Class \class{dabc::SocketThread} organises event loop, produced by sockets, assigned with
\class{dabc::SocketProcessor}. Processing of these events done by virtual methods
of class \class{dabc::SocketProcessor}, which has several subclasses for different 
kinds of sockets: 
\bbul
\item  - \class{dabc::SocketServerProcessor} - server socket handling  
\item  - \class{dabc::SocketClientProcessor} - server socket handling  
\item  - \class{dabc::SocketIOProcessor} - send/recv handling  
\ebul

Usage of socket processor classes requires that thread, 
to which such processors assigned should be of type \class{dabc::SocketThread}.
At the same time normal processors like \class{dabc::ModuleAsync} can work together
with \class{dabc::SocketThread}. Therefore, it is possible to run module and all its
socket transports in one single thread if socket thread for such module created in
advance:

\begin{verbatim}
  ...
  dabc::mgr()->CreateThread("GeneratorThrd", dabc::typeSocketThread);
  dabc::mgr()->CreateModule("Generator","mbs::GeneratorModule", "GeneratorThrd");
  dabc::mgr()->CreateTransport("Generator/Output", 
                  mbs::typeServerTransport, "GeneratorThrd");
  ...
\end{verbatim}
    

\section{Server transport}

Class \class{mbs::ServerTransport} was developed to provide MBS servers functionality in DABC.
Using this class one can emulate work of MBS transport server and MBS stream server. 
This is also good example of usage of \class{dabc::SocketProcessor} classes.

Implementation of \class{mbs::ServerTransport} based on generic class \class{dabc::Transport} and 
internally uses two kinds of sockets: socket for handling connection and I/O socket for 
sending data.
  
Server transport has following parameters:
\bbul
\item \param{MbsServerKind}  - kind of mbs server ("Transport" or "Stream")  
\item \param{MbsServerPort}  - port number for socket connection
\ebul

In previous section there is example of creation server transport with default
parameters. To instantiate MBS server tranport with user-defined parameters, 
following code should be used:

\begin{verbatim}
  ...
  dabc::Command* cmd = new dabc::CmdCreateTransport("Generator/Output", 
                         mbs::typeServerTransport, "MbsTransThrd");
  cmd->SetStr(mbs::xmlServerKind, mbs::ServerKindToStr(mbs::StreamServer));
  cmd->SetInt(mbs::xmlServerPort, mbs::DefualtServerPort(mbs::TransportServer) + 5);
  dabc::mgr()->Execute(cmd);
  ...
\end{verbatim}


\section{Client transport}

Class \class{mbs::ClientTransport} allows connect DABC with MBS. 
For the moment MBS transport and stream servers are supported.  

Client transport has following parameters:
\bbul
\item \param{MbsServerKind}  - kind of mbs server ("Transport" or "Stream") to connect to  
\item \param{MbsServerName}  - host name where mbs server runs 
\item \param{MbsServerPort}  - server port number for socket connection
\ebul

To create client connection, following pease of code should be used:

\begin{verbatim}
  ...
  dabc::Command* cmd = new dabc::CmdCreateTransport("Combiner/Input0", 
                         mbs::typeClientTransport, "MbsTransThrd");
  cmd->SetStr(mbs::xmlServerKind, mbs::ServerKindToStr(mbs::StreamServer));
  cmd->SetStr(mbs::xmlServerName, "lxi010.gsi.de");
  cmd->SetInt(mbs::xmlServerPort, mbs::DefualtServerPort(mbs::TransportServer) + 5);
  dabc::mgr()->Execute(cmd);
  ...
\end{verbatim}

 

\section{Events generator example}



\section{Local event building}

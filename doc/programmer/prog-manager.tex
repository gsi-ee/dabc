[programmer/prog-manager.tex]

\section{Introduction}
%this chapter covers the manager API description
The \class{Manager} is the central singleton object of the
\dabc~ framework. 
It combines a number of different roles, such as:

\bcir
\item object manager;
\item memory pool manager;
\item processing thread manager;
\item event handler;
\item command dispatcher and executor;
\item run control state manager;
\item plug-in manager for factories and application;
\item implementation of control and configuration system
\ecir

Although these functionalities internally could as well be treated in
separate classes, \class{dabc::Manager} class defines the common
application programmer's interface to access most of these features.
Since the manager is a singleton,
these methods are available everywhere in the user code
by means of the static handle \func{dabc::Manager::mgr()->}.


Following section \ref{prog_manager_framework} describes such interface methods to
be used by the programmer of the \class{Module}, \class{Transport}, \class{Device}, and \class{Application} classes.
In contrast to this, section \ref{prog_manager_controls} gives a guide how to
re-implement the \class{Manager} class itself for a different control and configuration
system. This should be seldomly  necessary for the common DAQ designer, 
but is added here as a reference and as useful insight into the \dabc~ mechanisms.


\section{Framework interface}
\label{prog_manager_framework}
here description of mostly used methods to be called from application, modules, etc.

\subsection{General object management}
\begin{description}

\item[\em Module* FindModule(const char* name)] :
Access to a \class{Module} by name. Returns $0$ if module does not exist.
   
\item[\em Port* FindPort(const char* name)]:
Access to a \class{Port} by name. Returns $0$ if port does not exist.
 

         
\item[\em Factory* FindFactory(const char* name)] :

\item[\em Device* FindDevice(const char* name)] :

\item[\em WorkingThread* FindThread(const char* name, const char* required\_class = 0)] :

\item[\em Device* FindLocalDevice(const char* name = 0)] :

\item[\em Application* GetApp()] : 

	 
\end{description}


\subsection{Module manipulation}	

\begin{description}

\item[\em void StartModule(const char* modulename)] :

\item[\em void StopModule(const char* modulename)] :

\item[\em bool StartAllModules(int appid = 0)] :

\item[\em bool StopAllModules(int appid = 0)] :

\item[\em bool DeleteModule(const char* name)] :

\item[\em bool IsModuleRunning(const char* name)] :
         
\item[\em bool IsAnyModuleRunning()] :


\item[\em bool ConnectPorts(const char* port1name,
                           const char* port2name,
                           const char* devname)] :
			   
\end{description}

\subsection{Factory methods}	 

\begin{description}
	 
\item[\em bool CreateApplication(const char* classname = 0, const char* appthrd = 0)] :


\item[\em bool CreateDevice(const char* classname, const char* devname)]: 

% \item[\em WorkingThread* CreateThread(const char* thrdname, const char* classname = 0, unsigned startmode = 0, const char* devname = 0, Command* cmd = 0)] :

\item[\em bool CreateModule(const char* classname, const char* modulename, const char* thrdname = 0)] : 

\item[\em bool CreateTransport(const char* portname, const char* transportkind, const char* thrdname = 0)] : 

\item[\em FileIO* CreateFileIO(const char* typ, const char* name, int option)] :


\end{description}	 
	 
\subsection{Command submission}	 
	
\begin{description}
 
\item[\em bool Submit(Command* cmd)] :
This method generally prepares a command \func{cmd} for execution.
The command is put in the queue of its command receiver working thread and is
then asynchronously executed there. The \class{Manager} will either forward the command
to its receiver, if such is specified as command parameter; or the \class{Manager} working thread itself will execute the command.
Thus method does not block and returns \keyw{true} if it accepts the command for execution, otherwise \keyw{false}. 

\item[\em bool SubmitLocal(CommandClientBase\& cli, Command* cmd, const char* fullitemname = "")] :
Prepares a command \func{cmd} for execution on the local node. The command receiver
is defined by the full name \func{fullitemname} in the object folder structure,
e.~g.~ "Modules/ReadoutModule1". The caller must provide a command client object
\func{cli} that will receive a command reply depending on the execution success.

\item[\em bool SubmitLocal(CommandClientBase\& cli, Command* cmd, Basic* rcv)] :
Prepares a command \func{cmd} for execution on the local node. The command receiver
\func{rcv} is passed directly by reference.
The caller must provide a command client object
\func{cli} that will receive a command reply depending on the execution success.


\item[\em bool SubmitRemote(CommandClientBase\& cli, Command* cmd, int nodeid, const char* itemname = "")] :
Prepares a command \func{cmd} for execution on a remote node. 
The execution node is specified by the unique \func{nodeid} in the DAQ
cluster. The command receiver on that node
is defined by the full name \func{fullitemname} in the object folder structure,
e.~g.~ "Modules/ReadoutModule1". The caller must provide a command client object
\func{cli} that will receive a command reply depending on the execution success.


\item[\em bool SubmitRemote(CommandClientBase\& cli, Command* cmd, const char* nodename, const char* itemname = "")] :
Prepares a command \func{cmd} for execution on a remote node. 
The execution node is specified by the unique \func{nodename} as defined
by the configuration system (see section \ref{prog_manager_controls_manager}).
The command receiver on that node
is defined by the full name \func{fullitemname} in the object folder structure,
e.~g.~ "Modules/ReadoutModule1". The caller must provide a command client object
\func{cli} that will receive a command reply depending on the execution success.






% 	   Command* LocalCmd(Command* cmd, const char* fullitemname = "");
% 
%          Command* LocalCmd(Command* cmd, Basic* rcv);
% 
%          Command* RemoteCmd(Command* cmd, const char* nodename, const char* itemname = "");
% 
%          Command* RemoteCmd(Command* cmd, int nodeid, const char* itemname = "");
% 
%          bool SubmitLocal(CommandClientBase& cli, Command* cmd, const char* fullitemname = "")
%             { return SubmitCl(cli, LocalCmd(cmd, fullitemname)); }
% 
%          bool SubmitLocal(CommandClientBase& cli, Command* cmd, Basic* rcv)
%            { return SubmitCl(cli, LocalCmd(cmd, rcv)); }
% 
%          bool SubmitRemote(CommandClientBase& cli, Command* cmd, const char* nodename, const char* itemname = "")
%            { return SubmitCl(cli, RemoteCmd(cmd, nodename, itemname)); }
% 
%          bool SubmitRemote(CommandClientBase& cli, Command* cmd, int nodeid, const char* itemname = "")
%            { return SubmitCl(cli, RemoteCmd(cmd, nodeid, itemname)); }


\end{description}
 
\subsection{Memory pool management}	 	   

\begin{description}	

\item[\em bool CreateMemoryPool(const char* poolname,
                               unsigned buffersize = 0,
                               unsigned numbuffers = 0,
                               unsigned numincrement = 0,
                               unsigned headersize = 0x20,
                               unsigned numsegments = 0)] : 
   
Generic method to create memory pool.
Creates (or extends) memory pool with numbuffers buffers of size buffersize.
Together with buffers memory pool creates number of reference objects with
preallocated header and gather list.
One can configure that memory pool can be extended "on the fly" -
numincrement value specifies how much buffers memory pool can extend at once.
In case when expanding of pool is allowed, one can limit total size
of pool via ConfigurePool method. There one can also specify how often
memory pool should try to cleanup unused memory.
         
	

\item[\em MemoryPool* FindPool(const char* name)] :
Access to memory pool by name \func{name}. Returns 0 if not found.

\item[\em bool DeletePool(const char* name)] :
Delete memory pool of name \func{name}. Returns true or false depending on success.
   
\end{description}
	 
\section{Control system plug-in}
\label{prog_manager_controls}
For the common \dabc~ usage, the provided standard control and configuration system,
featuring DIM protocol \cite{DIM}, XML setup files, and a generic Java GUI,
will probably be sufficient.
However, if e.~g.~
an experiment control system is already existing and the data acquisition
shall be handled with the same means,
it might be necessary to adjust \dabc~ to another
controls and configuration framework.
Moreover, future developments may replace the current standard control
system by a more powerful, or a more convenient one.

Because of this, the connection between the \dabc~ core system and the
control system implementation was designed with a clear plug-in interface.
Again the \class{dabc::Manager} class plays here a key role.

This section covers all methods and mechanisms for
the control system plug-in. As an example, part \ref{prog_manager_controls_DIM}  
describes in detail the standard implementation as delivered with the \dabc~ distribution .



\subsection{Factory}
 \label{prog_manager_controls_factory}
A new control system plug-in is added into \dabc~, 
by means of a \class{dabc::Factory} subclass that  
defines the method
\func{bool CreateManagerInstance(const char* kind, dabc::Configuration* cfg)}.
This method should
create the appropriate \class{dabc::Manager} instance and return \keyw{true} 
if the name \func{kind}, as specified by the runtime environment,
matches the implementation.
The default \dabc~ runtime executable will also pass 
a configuration object \func{cfg} read from an XML file which may be
passed to the constructor of the \class{Manager}.

As it's mandatory for other \dabc~ factories, 
the \class{dabc::Factory} for the manager must be
instantiated as global object in the code that implements it.
This assures that the factory exists in the system on
loading the corresponding library.

\subsection{Manager}
\label{prog_manager_controls_manager}
Besides its role as a central singleton to access framework functionalities,
the \class{dabc::Manager} is also the interface base class for the 
control and configuration system that is applied with \dabc~. 

\subsubsection{Virtual methods}
The \class{dabc::Manager} defines several virtual methods concerning the {\em finite state machine},the registration and subscription of parameters, the command communication
in-between nodes, and the management of a DAQ cluster, resp.
These methods have to be implemented for differrent kinds of control systems in
an appropriate subclass and are described as follows:

%\begin{compactdesc}
\begin{description}

\item[\em Manager(const char* managername,  bool usecurrentprocess, Configuration* cfg)] :
The constructor of the subclass. The recommended parameters 
are passed from the manager factory (see section \ref{prog_manager_controls_factory})
to the baseclass constructor, such as
the object name of the manager; optionally a
flag indicating to use either the main process or another thread for manager 
command execution;
and an optional configuration object \func{cfg}.
\begin{compactenum}

\item The constructor should initialize the control system implementation.

\item If the default state machine module of the \dabc~ core is used, the constructor
should invoke method \func{InitSMmodule()}. Otherwise, the constructor must
initialize an external state machine of the control system, following the
state and transition names defined as static constants in {\tt dabc/Manager.h}. 

\item The constructor must call method \func{init()} to initialize the base
functionalities and parameters. This should be done {\em after} the control system
is ready for handling parameters and commands, and {\em after} the optional \func{InitSMmodule()} call.
  
\end{compactenum}     


     
\item[\em\~{~}Manager()] :
The destructor of the subclass. It should cleanup and remove the  
control system implementation. It must call method \func{destroy()}
at the end.    


\item[\em bool InvokeStateTransition(const char* state\_transition\_name, 
Command* cmd)] : 
This should initiate the state transition for the given \func{state\_transition\_name}.
This \strong{must} be an asynchronous function that does not block the calling thread,
possibliy the main manager thread if the state transition is triggered by a command
from a remote "master" state machine node. Thus the actual state transition should be performed in a dedicated state-machine thread, calling the synchronous method
\func{DoStateTransition(const char*)} of the base class (see section \ref{prog_manager_controls_base}).

Synchronization of the state with the invoking client is done by
the passed command object reference \func{cmd}. 
This should be used as handle in the static call \func{dabc::Command::Reply(cmd,true)} when the state transition is completed, or \func{dabc::Command::Reply(cmd,false)} when the transition has been failed, resp.

Note that base class \class{dabc::Manager} already implements this method for the 
\dabc~ default state machine module which is activated in the
manager constructor with \func{InitSMmodule()}. It needs a re-implementation only if
an external state machine shall be used.



\item[\em void ParameterEvent(dabc::Parameter* par, int event)] :
Is invoked by the framework when any \class{Parameter} is created 
(argument value $event=0$),  changed ($event=1$),
or destroyed ($event=2$), resp. Pointer \func{par} should be used to access parameter
name and value for export to the control system. 


\item[\em void CommandRegistration(dabc::Module* m, dabc::CommandDefinition* def, bool reg)] :
Is invoked by the framework when any module exports (argument \func{reg} \keyw{true}), or
unexports (argument \func{reg} \keyw{false}) a \class{dabc::Command}
to, or from the control system, resp. This allows to invoke such 
commands via the controls connection from a remote node. 
The command definition object \func{def}
contains a description of possible command parameters; 
pointer \func{m} should be used to access the owning module and
get its name. This information may be used to represent the command within
the controls implementation.




\item[\em bool Subscribe(dabc::Parameter* par, int remnode, 
const char* remname)] :
This method shall link the value of a local parameter \func{par} to a remote parameter
of name \func{remname} that exists on node number \func{remnode} of the DAQ
cluster. Control system implementation may use a publisher-subscriber mechanism here
to update the local subscription whenever the remote parameter changes its value.

The actual update handler must call method \func{InvokeChange(const char* val)}
of the corresponding local representation \func {dabc::Parameter* par} then.
The new value \func{val} is passed as ({\tt printf()} style formatted) 
text representation to the parameter which 
will change itself appropriately. This decouples the parameter change
from the invoking control system callback in a thread-safe manner.

\item[\em bool Unsubscribe(dabc::Parameter* par)] : 
The subscription of a local parameter \func{par} to a remote paramter by
a formerly called \func{Subscribe()} is removed from the control system.


\item[\em bool IsMainManager()] :
Should return \keyw{true} if this node is the single 
master controller node of the DAQ cluster. This node will define
the master state machine that rules the states 
of all other nodes.
Otherwise (returns \keyw{false}) this node is a simple worker node.
The node properties should be taken from the configuration.

\item[\em bool HasClusterInfo()]:
Returns \keyw{true} if this node has complete information of the DAQ cluster.


\item[\em int NumNodes()] :
Returns the number of all DAQ nodes in the cluster. This may be taken
from a configuration database, e.~g.~ an XML file, but may also test the
real number of running nodes each time it's called.

\item[\em int NodeId() const] : 
Returns the unique id number of this node in the DAQ cluster.
This should be taken from the cluster configuration.

\item[\em bool IsNodeActive(int num)] : 
Returns \keyw{true} if DAQ cluster node of id number \func{num}
is currently active, otherwise \keyw{false}. 
This may allow to check on runtime if some of the
configured nodes are not available and should be excluded from the
DAQ setup.

\item[\em const char* GetNodeName(int num)] :
For each DAQ cluster node of id number \func{num},
this method must define a unique name representation. 
The name should represent the node in a human readable
way, e.~g.~ by means of URL and a functional node description
("daq01.gsi.de-readout"). It should match the
description in the cluster configuration.
Note: This name \strong{must} match the local name
of the manager object on each node.



\item[\em bool SendOverCommandChannel(const char* managername, const char* cmddata)] :
This method sends a \class{dabc::Command} as a streamed text representation \func{cmddata}
to a remote DAQ cluster node of name \func{managername}.
The \func{managername} argument must match one of the names defined in
\func{GetNodeName(int num)}. The implementation should use
transport mechanisms of the control system to transfer the
command string to the remote site 
(e.~g.~ native control commands that wrap \func{cmddata}).
The receiver of such commands on the target node
should call base class method
\func{RecvOverCommandChannel(const char* cmddata)} to 
forward the command representation to the core system,
which will reconstruct and execute the \class{dabc::Command} object. 

 
\item[\em bool CanSendCmdToManager(const char* mgrname)] :
Returns \keyw{true} if it is possible to send a remote
command to the manager on DAQ cluster node of name \func{mgrname},
otherwise \keyw{false}. 
The node name argument must match one of the names defined in
\func{GetNodeName(int num)}.
This method may implement to forbid the sending of commands on some nodes.


\item[\em int ExecuteCommand(dabc::Command* cmd)] :
This method executes synchronously any
\dabc~ command that is submitted to this manager itself.
It will run in the scope of the manager thread
(depending on constructor argument \func{usecurrentprocess}, 
this is either the main process thread, or a dedicated manager thread).

It may be re-implemented to add new commands required for the
controls implementation. The \dabc~ mechanism of
methods \func{SubmitCommand()} and \func{ExecuteCommand()} may allow
to decouple control system callbacks from their execution thread.

 
\end{description}
%\end{compactdesc}


\subsubsection{Baseclass methods}
\label{prog_manager_controls_base}
In addition to the virtual methods to be implemented in the manager subclass,
there is a number of \class{dabc::Manager} base class methods 
that should be called from the control system to perform actions of the 
framework:

\begin{description}

 
\item[\em bool DoStateTransition(const char* state\_transition\_cmd)] :
Performs the state machine transition of name \func{state\_transition\_cmd}.
This method is synchronous and returns no sooner than the 
transition actions are completed (true) or an error is detected (false).
Note that the real transition actions are still user defined in methods
of the \class{dabc::Application} implementation.

\item[\em bool IsStateTransitionAllowed(const char* state\_transition\_cmd, bool errout)] :
Checks if state transition of name \func{state\_transition\_cmd} is allowed
for the default state machine implementation (which should be reproduced exactly by
any external SM implementation) and returns true or false, resp. Argument
\func{errout} may specify if error messages shall be printed to {\tt stdout}.

\item[\em RecvOverCommandChannel(const char* cmddata)] :
Receives a \dabc~ command as text stream \func{cmddata} 
from a remote node. Usually this function should be called in a
receiving callback of the control system communication layer,
passing the received command representation to the core system.
Here the command object is unstreamed again, forwarded to its
receiver and executed.

This is the pendant to virtual method 
\func{SendOverCommandChannel()} which should implement the \strong{sending} 
of a streamed command from the core to a remote manager by transport mechanisms of the control system. 

 
 
\end{description}






\subsection{Default implementation for DIM}
\label{prog_manager_controls_DIM}
The \dabc~ default controls and configuration system 
is based on the DIM library \cite{DIM} and is marked by namespace
\class{dimc::} (for "DIM Control"). 
% It features the DIM publisher-subscriber mechanism with \dabc~ process records and uses state machine module and XML parser as provided by the \dabc~core system. 
The main classes are described in the following:

\subsubsection{\class{dimc::Manager}}
Implements the control system interface of
\class{dabc::Manager} as described above. 

\begin{compactenum}

\item It uses the \strong{default state machine module} of the \dabc~core system.
This is activated in \class{dimc::Manager} constructor by calling
\func{InitSMmodule()}. Thus virtual method \func{InvokeStateTransition()}
is \strong{not} re-implemented here.

\item It exports a dedicated \class{dabc::StatusParameter} that is
synchronized with the value of the core state machine in \func{ParameterEvent()}. 
This parameter is required to display the state of the node on the generic
Java GUI.

\item It applies the generic \class{dabc::Configuration}  for setting up
the node properties. The standard \dabc~ runtime executable will create the \class{dabc::Configuration} object from parsing an XML file. 

\item The other interface functionalities use one
component of class \class{dimc::Registry}.

\end{compactenum}




\subsubsection{\class{dimc::Registry}}

The main component of the \class{dimc::Manager} that
offers service methods really implementing the manager interface.
It registers all parameters, commands, and subscriptions; 
and it defines the allowed access methods for the DIM server itself.
 
\begin{compactenum}

\item The \strong{DIM server} is instantiated in the constructor as	 \class{dimc:Server}
singleton. Methods \func{StartDIMServer()} and \func{StopDIMServer()} 
actually initiate and terminate the service. 

\item \strong{Naming of nodes and services:}
Method \func{GetNodeName(int num)} of \class{dimc::Manager} 
uses \func{CreateDIMPrefix(num)} of \class{dimc::Registry}.
This evaluates the unique name for node number \func{num} 
from the \class{dabc::Configuration} object: It consists of
a global prefix ("DABC"), the configuration \func{NodeName()}, and the
\func{ContextName()} property of the node id,
all separated by forward slashes ("/").

The node name is also taken as prefix for the helper
methods \func{BuildDIMName()} (\func{ReduceDIMName()}, resp.) that 
transform local \dabc~ parameter and command names 
into unique DIM names (and back, resp.). 
Moreover, methods \func{CreateFullParameterName()}
(\func{ParseFullParameterName()}, resp.) define how
the local parameter name itself is composed (decomposed, resp.) from the names
of its parent module and its internal variable name. They
utilize corresponding static methods of class \class{dimc::nameParser}
in a thread-safe way.

     
\item \strong{Parameter export:} \func{dimc::Manager::ParameterEvent()}
uses methods \func{RegisterParameter()} (and
\func{UnregisterParameter()}, resp.) to declare (undeclare, resp.) 
a corresponding DIM service. Here the \class{dimc::Registry}
keeps auxiliary objects of class 
\class{dimc::ServiceEntry} that link the \class{DimService} with the \class{dabc::Parameter}. On parameter change, method 
\func{ParameterUpdated()} will initiate an update of the corresponding DIM
service.
    
\item \strong{Control system commands:} Method \func{DefineDIMCommand(const char* name)} 
creates and registers simple (char array) \class{DimCommand} objects
that may be executed on this node. The \class{dimc::Registry} constructor
defines commands for all state machine transitions, 
such as Configure, Enable, Halt, Start, Stop. Additionally, there are DIM commands for
shutting down the node, setting a parameter value, and
wrapping a \dabc~ 
command as string representation ({\em "ManagerCommand"} for \func{SendOverCommandChannel()},
see section \ref{prog_manager_controls_manager}), resp.

Moreover, a \dabc~ module may register a 
\class{dabc::Command} as new control system command on the fly.
In this case \class{dimc::Manager} method
\func{CommandRegistration()} will use
\func{RegisterModuleCommand()} of \class{dimc::Registry}.
This will both define  a \class{DimCommand}, and
publish a corresponding command descriptor as DIM service to
announce the command structure to the generic Java GUI.
Method \func{UnRegisterModuleCommand()} may remove command and 
descriptor service again.


When the DIM server receives a remote command, 
method \func{HandleDIMCommand()} checks if this command
is registered; then \func{OnDIMCommand()} will transform the
\class{DimCommand} into a \class{dabc::Command} and \func{Submit()}
this to the Manager. The actual command execution will thus happen
in re-implemented method \func{ExecuteCommand()} of \class{dimc::Manager}.
Thus the command action runs independent of the DIM commandhandler thread.

\item \strong{Parameter subscription:}
Method \func{Subscribe()} (\func{Unsubscribe()}, resp.) of \class{dimc::Manager} 
are forwarded to \func{SubscribeParameter()} (UnsubscribeParameter() , resp. ) 
of \class{dimc::Registry}.
These implement it by means of the \class{DimService} update mechanism. 
Subscriptions are kept as vector of \class{dimc::DimParameterInfo} objects.
This is a subclass of \class{DimStampedInfo} with a back reference to the subscribed \class{dabc::Parameter}


\item \strong{Remote command execution:}   
Method \func{SendOverCommandChannel()} of \class{dimc::Manager}    
is forwarded to  \func{SendDimCommand()} of \class{dimc::Registry}.
The streamed \class{dabc::Command} is wrapped as text argument
into the DIM {\em ManagerCommand} and send to the destination
by node name via \func{DimClient::sendCommand()}.    
    
    
    
\end{compactenum}    

\subsubsection{\class{dimc::Server}}
    
Subclass of DIM class \class{DimServer}, implementing command handler, error handler, and exit handlers for client and server exit events.

\begin{compactenum}

\item Because most DIM server actions are invoked by static methods of \class{DimServer}, it is reasonable to have only one instance of \class{dimc::Server}; 
thus this class is designed as \strong{singleton pattern}. Access and initial creation is provided by method \func{Instance()}. A safe cleanup is granted by \func{Delete()} (ctors and dtors are private and cannot be invoked directly).

\item The \class{dimc::Registry} is set as "owner" of \class{dimc::Server} by means
of a back pointer. All handler methods of the \class{DimServer} are
implemented as forward calls to corresponding methods of the 
\class{dimc::Registry} and treated there, such as:
\bcir
	\item \func{commandHandler()} to \func{HandleDIMCommand()}
	\item \func{errorHandler()} to \func{OnErrorDIMServer()}
	\item \func{clientExitHandler()} to \func{OnExitDIMClient()}
	\item \func{exitHandler()} to \func{OnExitDIMServer()}
\ecir


    
\end{compactenum}

    
\subsubsection{\class{dimc::ServiceEntry}}
This is a container to keep the \class{DimService} together with 
the corresponding \class{dabc::Parameter} object and some extra properties.
The \class{dimc::ServiceEntry} objects are managed by the
\class{dimc::Registry} and applied for the 
\func{RegisterParameter()}  method.


\begin{compactenum} 

\item For \class{std::string} parameters an internal \class{char*} array is used as buffer which is actually exported as DIM service.

\item Method \func{UpdateBuffer()} updates the DIM service; it optionally may copy the
parameter contents to the buffer before.

\item Method \func{SetValue()} sets the \class{dabc::Parameter} to a new value, as defined by a string expression.

\end{compactenum}


\subsubsection{\class{dimc::ParameterInfo}}
A subclass of DIM class \class{DimStampedInfo} which subscribes
to be informed if a remote DIM service changes its value. 
The \class{dimc::ParameterInfo} objects are managed by the
\class{dimc::Registry} and applied for the \func{Subscribe()} method.

\begin{compactenum} 

\item The \class{dimc::ParameterInfo} has a reference to
a local \class{dabc::Parameter} object that shall be updated
if the subscribed service changes. 

\item Depending on the subscribing \class{dabc::Parameter} type
(integer, double, string,...), the \class{dimc::ParameterInfo} constructor will
instantiate an appropriate \class{DimStampedInfo} type.

\item Method \func{infoHandler()} of \class{DimStampedInfo} 
is implemented to update the parameter to the new value
by means of an \func{InvokeChange()} call.

\end{compactenum}





%%%%%%%%%%%%%%%%5    
 
 
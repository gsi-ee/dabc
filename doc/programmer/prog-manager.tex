[programmer/prog-manager.tex]

\section{Introduction}
this chapter covers the manager API description


\section{Framework interface}
here description of mostly used methods to be called from application, modules, etc.


\section{Control system plug-in}

%\subsection{Interfaces}

\subsection{Factory}
 \label{prog_controls_manfactory}
A new control system plug-in is added into \dabc~, 
by means of a \class{dabc::Factory} subclass that  
defines the method
\func{bool CreateManagerInstance(const char* kind, dabc::Configuration* cfg)}.
This method should
create the appropriate \class{dabc::Manager} instance and return \keyw{true} 
if the name \func{kind}, as specified by the runtime environment,
matches the implementation.
The default \dabc~ runtime executable will also pass 
a configuration object \func{cfg} read from an XML file which may be
passed to the constructor of the \class{Manager}.

As it's mandatory for other \dabc~ factories, 
the \class{dabc::Factory} for the manager must be
instantiated as global object in the code that implements it.
This assures that the factory exists in the system on
loading the corresponding library.

\subsection{Manager}
\label{prog_controls_manager}
Besides its role as a central singleton to access framework functionalities,
the \class{dabc::Manager} is also the interface base class for the 
control and configuration system that is applied with \dabc~. 

\subsubsection{Virtual methods}
The \class{dabc::Manager} defines several virtual methods concerning the {\em finite state machine},the registration and subscription of parameters, the command communication
in-between nodes, and the management of a DAQ cluster, resp.
These methods have to be implemented for differrent kinds of control systems in
an appropriate subclass and are described as follows:

%\begin{compactdesc}
\begin{description}

\item[\em Manager(const char* managername,  bool usecurrentprocess, configuration* cfg)] :
The constructor of the subclass. The recommended parameters 
are passed from the manager factory (see section \ref{prog_controls_manfactory})
to the baseclass constructor, such as
the object name of the manager; optionally a
flag indicating to use either the main process or another thread for manager 
command execution;
and an optional configuration object \func{cfg}.
\begin{compactenum}

\item The constructor should initialize the control system implementation.

\item If the default state machine module of the \dabc~ core is used, the constructor
should invoke method \func{InitSMmodule()}. Otherwise, the constructor must
initialize an external state machine of the control system, following the
state and transition names defined as static constants in {\tt dabc/Manager.h}. 

\item The constructor must call method \func{init()} to initialize the base
functionalities and parameters. This should be done {\em after} the control system
is ready for handling parameters and commands, and {\em after} the optional \func{InitSMmodule()} call.
  
\end{compactenum}     


     
\item[\em\~{~}Manager()] :
The destructor of the subclass. It should cleanup and remove the  
control system implementation. It must call method \func{destroy()}
at the end.    


\item[\em bool InvokeStateTransition(const char* state\_transition\_name, 
Command* cmd)] : 
This should initiate the state transition for the given \func{state\_transition\_name}.
This \strong{must} be an asynchronous function that does not block the calling thread,
possibliy the main manager thread if the state transition is triggered by a command
from a remote "master" state machine node. Thus the actual state transition should be performed in a dedicated state-machine thread, calling the synchronous method
\func{DoStateTransition(const char*)} of the base class (see section \ref{prog_controls_manager_base}).

Synchronization of the state with the invoking client is done by
the passed command object reference \func{cmd}. 
This should be used as handle in the static call \func{dabc::Command::Reply(cmd,true)} when the state transition is completed, or \func{dabc::Command::Reply(cmd,false)} when the transition has been failed, resp.

Note that base class \class{dabc::Manager} already implements this method for the 
\dabc~ default state machine module which is activated in the
manager constructor with \func{InitSMmodule()}. It needs a re-implementation only if
an external state machine shall be used.



\item[\em void ParameterEvent(dabc::Parameter* par, int event)] :
Is invoked by the framework when any \class{Parameter} is created 
(argument value $event=0$),  changed ($event=1$),
or destroyed ($event=2$), resp. Pointer \func{par} should be used to access parameter
name and value for export to the control system. 


\item[\em void CommandRegistration(dabc::Module* m, dabc::CommandDefinition* def, bool reg)] :
Is invoked by the framework when any module exports (argument \func{reg} \keyw{true}), or
unexports (argument \func{reg} \keyw{false}) a \class{dabc::Command}
to, or from the control system, resp. This allows to invoke such 
commands via the controls connection from a remote node. 
The command definition object \func{def}
contains a description of possible command parameters; 
pointer \func{m} should be used to access the owning module and
get its name. This information may be used to represent the command within
the controls implementation.




\item[\em bool Subscribe(dabc::Parameter* par, int remnode, 
const char* remname)] :
This method shall link the value of a local parameter \func{par} to a remote parameter
of name \func{remname} that exists on node number \func{remnode} of the DAQ
cluster. Control system implementation may use a publisher-subscriber mechanism here
to update the local subscription whenever the remote parameter changes its value.

The actual update handler must call method \func{InvokeChange(const char* val)}
of the corresponding local representation \func {dabc::Parameter* par} then.
The new value \func{val} is passed as ({\tt printf()} style formatted) 
text representation to the parameter which 
will change itself appropriately. This decouples the parameter change
from the invoking control system callback in a thread-safe manner.

\item[\em bool Unsubscribe(dabc::Parameter* par)] : 
The subscription of a local parameter \func{par} to a remote paramter by
a formerly called \func{Subscribe()} is removed from the control system.


\item[\em bool IsMainManager()] :
Should return \keyw{true} if this node is the single 
master controller node of the DAQ cluster. This node will define
the master state machine that rules the states 
of all other nodes.
Otherwise (returns \keyw{false}) this node is a simple worker node.
The node properties should be taken from the configuration.

\item[\em bool HasClusterInfo()]:
Returns \keyw{true} if this node has complete information of the DAQ cluster.


\item[\em int NumNodes()] :
Returns the number of all DAQ nodes in the cluster. This may be taken
from a configuration database, e.~g.~ an XML file, but may also test the
real number of running nodes each time it's called.

\item[\em int NodeId() const] : 
Returns the unique id number of this node in the DAQ cluster.
This should be taken from the cluster configuration.

\item[\em bool IsNodeActive(int num)] : 
Returns \keyw{true} if DAQ cluster node of id number \func{num}
is currently active, otherwise \keyw{false}. 
This may allow to check on runtime if some of the
configured nodes are not available and should be excluded from the
DAQ setup.

\item[\em const char* GetNodeName(int num)] :
For each DAQ cluster node of id number \func{num},
this method must define a unique name representation. 
The name should represent the node in a human readable
way, e.~g.~ by means of URL and a functional node description
("daq01.gsi.de-readout"). It should match the
description in the cluster configuration.
Note: This name \strong{must} match the local name
of the manager object on each node.



\item[\em bool SendOverCommandChannel(const char* managername, const char* cmddata)] :
This method sends a \class{dabc::Command} as a streamed text representation \func{cmddata}
to a remote DAQ cluster node of name \func{managername}.
The \func{managername} argument must match one of the names defined in
\func{GetNodeName(int num)}. The implementation should use
transport mechanisms of the control system to transfer the
command string to the remote site 
(e.~g.~ native control commands that wrap \func{cmddata}).
The receiver of such commands on the target node
should call base class method
\func{RecvOverCommandChannel(const char* cmddata)} to 
forward the command representation to the core system,
which will reconstruct and execute the \class{dabc::Command} object. 

 
\item[\em bool CanSendCmdToManager(const char* mgrname)] :
Returns \keyw{true} if it is possible to send a remote
command to the manager on DAQ cluster node of name \func{mgrname},
otherwise \keyw{false}. 
The node name argument must match one of the names defined in
\func{GetNodeName(int num)}.
This method may implement to forbid the sending of commands on some nodes.


\item[\em int ExecuteCommand(dabc::Command* cmd)] :
This method executes synchronously any
\dabc~ command that is submitted to this manager itself.
It will run in the scope of the manager thread
(depending on constructor argument \func{usecurrentprocess}, 
this is either the main process thread, or a dedicated manager thread).

It may be re-implemented to add new commands required for the
controls implementation. The \dabc~ mechanism of
methods \func{SubmitCommand()} and \func{ExecuteCommand()} may allow
to decouple control system callbacks from their execution thread.

 
\end{description}
%\end{compactdesc}


\subsubsection{Baseclass methods}
\label{prog_controls_manager_base}
In addition to the virtual methods to be implemented in the manager subclass,
there is a number of \class{dabc::Manager} base class methods 
that should be called from the control system to perform actions of the 
framework:

\begin{description}

 
\item[\em bool DoStateTransition(const char* state\_transition\_cmd)] :
Performs the state machine transition of name \func{state\_transition\_cmd}.
This method is synchronous and returns no sooner than the 
transition actions are completed (true) or an error is detected (false).
Note that the real transition actions are still user defined in methods
of the \class{dabc::Application} implementation.

\item[\em bool IsStateTransitionAllowed(const char* state\_transition\_cmd, bool errout)] :
Checks if state transition of name \func{state\_transition\_cmd} is allowed
for the default state machine implementation (which should be reproduced exactly by
any external SM implementation) and returns true or false, resp. Argument
\func{errout} may specify if error messages shall be printed to {\tt stdout}.

\item[\em RecvOverCommandChannel(const char* cmddata)] :
Receives a \dabc~ command as text stream \func{cmddata} 
from a remote node. Usually this function should be called in a
receiving callback of the control system communication layer,
passing the received command representation to the core system.
Here the command object is unstreamed again, forwarded to its
receiver and executed.

This is the pendant to virtual method 
\func{SendOverCommandChannel()} which should implement the \strong{sending} 
of a streamed command from the core to a remote manager by transport mechanisms of the control system. 

 
 
\end{description}






\subsection{Default implementation for DIM}
The \dabc~ default controls and configuration system 
is based on the DIM library \cite{DIM} and is marked by namespace
\class{dimc::} (for "DIM Control"). It features the DIM publisher-subscriber mechanism with \dabc~ process records and uses state machine module and XML parser as provided by the 
\dabc~core system. The main classes are described in the following:

\subsubsection{\class{dimc::Manager}}
Implements the control system interface of
\class{dabc::Manager} as described above.   

% \begin{compactenum}
% 
% \item Implements SendOverCommandChannel() to transport core commands over the dabc::xd DIM layer.
% 
% \item Implements ParameterEvent(): Interface method to register and update dabc parameter to infospace and DIM. If parameter is created, its contstructor calls this method. Depending on parameter type it is registered using Add...Record() methods of Registry. Vice versa, on parameter deletion it is removed via RemoveRecord(). If module parameter changes value, this is forwarded using Update...Record().
% 
% \item Implements CommandRegistration() : Interface method to register or unregister a module command as a DIM command and corresponding command descriptor service. Uses internally dimc::Registry::RegisterModuleCommand() and ...UnRegisterModuleCommand() methods.
% 
% \item Implements ModuleException() to react to a dabc::exception if thrown in a module. So far, we only do error output here. TODO: concept of exception handling in modules, threads and control system!
% 
% \item Implements methods for the daq cluster management: GetNodeName() , NodeId() to map the unique node id number as used in the core with an arbitrary node name of the configuration/control system; NodeId() delivers the id of the current node. NumNodes() returns the number of all configured cluster nodes as known from the set up. These methods are just forwards to corresponding interface methods of Node.
% 
% \item Implements Subscribe() and Unsubscribe() for parameters. These methods are just forwards to corresponding interface methods Registry::SubscribeParameter() , and ..:UnsubscribeParameter() , resp.
% 
% \item Implements InvokeStateTransition(). This method is forwarded to corresponding interface method of Node.
% 
% \end{compactenum}
%%%%%%%%%%%%%%5

\subsubsection{\class{dimc::Registry}}
%\item[\class{dimc::Registry}] :

The main component of the \class{dimc::Manager} that
offers service methods really implementing the manager interface.
It registers all parameters, commands, and subscriptions; 
and it defines the allowed access methods for the DIM server itself.
 
\begin{compactenum}

\item The \strong{DIM server} is instantiated in the constructor as	 \class{dimc:Server}
singleton. Methods \func{StartDIMServer()} and \func{StopDIMServer()} 
actually initiate and terminate the service. 

\item \strong{Naming of nodes and services:}
Method \func{GetNodeName(int num)} of \class{dimc::Manager} 
uses \func{CreateDIMPrefix(num)} of \class{dimc::Registry}.
This evaluates the unique name for node number \func{num} 
from the \class{dabc::Configuration} object: It consists of
a global prefix ("DABC"), the configuration \func{NodeName()}, and the
\func{ContextName()} property of the node id,
all separated by forward slashes ("/").

The node name is also taken as prefix for the helper
methods \func{BuildDIMName()} (\func{ReduceDIMName()}, resp.) that 
transform local \dabc~ parameter and command names 
into unique DIM names (and back, resp.). 
Moreover, methods \func{CreateFullParameterName()}
(\func{ParseFullParameterName()}, resp.) define how
the local parameter name itself is composed (decomposed, resp.) from the names
of its parent module and its internal variable name. They
utilize corresponding static methods of class \class{dimc::nameParser}
in a thread-safe way.

     
\item \strong{Parameter export:} \func{dimc::Manager::ParameterEvent()}
uses methods \func{RegisterParameter()} (and
\func{UnregisterParameter()}, resp.) to declare (undeclare, resp.) 
a corresponding DIM service. Here the \class{dimc::Registry}
keeps auxiliary objects of class 
\class{dimc::ServiceEntry} that link the \class{DimService} with the \class{dabc::Parameter}. On parameter change, method 
\func{ParameterUpdated()} will initiate an update of the corresponding DIM
service.
    
\item \strong{Control system commands:} Method \func{DefineDIMCommand(const char* name)} 
creates and registers simple (char array) \class{DimCommand} objects
that may be executed on this node. The \class{dimc::Registry} constructor
defines commands for all state machine transitions, 
such as Configure, Enable, Halt, Start, Stop. Additionally, there are DIM commands for
shutting down the node, setting a parameter value, and
wrapping a \dabc~ 
command as string representation ({\em "ManagerCommand"} for \func{SendOverCommandChannel()},
see section \ref{prog_controls_manager}), resp.

Moreover, a \dabc~ module may register a 
\class{dabc::Command} as new control system command on the fly.
In this case \class{dimc::Manager} method
\func{CommandRegistration()} will use
\func{RegisterModuleCommand()} of \class{dimc::Registry}.
This will both define  a \class{DimCommand}, and
publish a corresponding command descriptor as DIM service to
announce the command structure to the generic Java GUI.
Method \func{UnRegisterModuleCommand()} may remove command and 
descriptor service again.


When the DIM server receives a remote command, 
method \func{HandleDIMCommand()} checks if this command
is registered; then \func{OnDIMCommand()} will transform the
\class{DimCommand} into a \class{dabc::Command} and \func{Submit()}
this to the Manager. The actual command execution will thus happen
in re-implemented method \func{ExecuteCommand()} of \class{dimc::Manager}.
Thus the command action runs independent of the DIM commandhandler thread.

\item \strong{Parameter subscription:}
Method \func{Subscribe()} (\func{Unsubscribe()}, resp.) of \class{dimc::Manager} 
are forwarded to \func{SubscribeParameter()} (UnsubscribeParameter() , resp. ) 
of \class{dimc::Registry}.
These implement it by means of the \class{DimService} update mechanism. 
Subscriptions are kept as vector of \class{dimc::DimParameterInfo} objects.
This is a subclass of \class{DimStampedInfo} with a back reference to the subscribed \class{dabc::Parameter}


\item \strong{Remote command execution:}   
Method \func{SendOverCommandChannel()} of \class{dimc::Manager}    
is forwarded to  \func{SendDimCommand()} of \class{dimc::Registry}.
The streamed \class{dabc::Command} is wrapped as text argument
into the DIM {\em ManagerCommand} and send to the destination
by node name via \func{DimClient::sendCommand()}.    
    
    
    
\end{compactenum}    

\subsubsection{\class{dimc::Server}}
    
Subclass of DIM class \class{DimServer}, implementing command handler, error handler, and exit handlers for client and server exit events.

\begin{compactenum}

\item Because most DIM server actions are invoked by static methods of \class{DimServer}, it is reasonable to have only one instance of \class{dimc::Server}; 
thus this class is designed as \strong{singleton pattern}. Access and initial creation is provided by method \func{Instance()}. A safe cleanup is granted by \func{Delete()} (ctors and dtors are private and cannot be invoked directly).

\item The \class{dimc::Registry} is set as "owner" of \class{dimc::Server} by means
of a back pointer. All handler methods of the \class{DimServer} are
implemented as forward calls to corresponding methods of the 
\class{dimc::Registry} and treated there, such as:
\bcir
	\item \func{commandHandler()} to \func{HandleDIMCommand()}
	\item \func{errorHandler()} to \func{OnErrorDIMServer()}
	\item \func{clientExitHandler()} to \func{OnExitDIMClient()}
	\item \func{exitHandler()} to \func{OnExitDIMServer()}
\ecir


    
\end{compactenum}

    
\subsubsection{\class{dimc::ServiceEntry}}
This is a container to keep the \class{DimService} together with 
the corresponding \class{dabc::Parameter} object and some extra properties.

\begin{compactenum} 

\item For \class{std::string} parameters an internal \class{char*} array is used as buffer which is actually exported as DIM service.

\item Method \func{UpdateBuffer()} updates the DIM service; it optionally may copy the
parameter contents to the buffer before.

\item Method \func{SetValue()} sets the \class{dabc::Parameter} to a new value, as defined by a string expression.

\end{compactenum}


\subsubsection{\class{dimc::ParameterInfo}}









%%%%%%%%%%%%%%%%5    
 
 
[programmer/prog-services.tex]

\section{Memory management}
\label{prog_services_memory}
\subsection{Zero-copy approach}
Complete \dabc~ framework build around dataflow concept, where data (buffers) 
flowing through many components like modules, transports and devices. 
If on each step one will require to copy of data content, this will reduce 
performance drastically. Therefore \dabc~ provides central memory management
and all components use references to this memory. 
Such approach is called zero-copy approach and fully supported by \dabc~.


\subsection{Memory pool}
\label{prog_services_memory_pool}
Memory in \class{dabc::MemoryPool} organized in big blocks of contiguous virtual memory.
Each block divided on peaces (buffers) of the same size, size of each peace is a power of 2.
Memory pool can has several memory blocks with different size of buffers.

Usually memory pool has fixed structure - means memory allocated once and will not
change during complete run. It is preferable mode of operation, while any 
memory allocation may lead into undefined execution time or even cause error, while
system has no resources. Nevertheless, one can configure memory pool to be extendable -  
memory pool will allocate new blocks in case when there is no more buffers available.   

Each buffer in memory pool has 32-bit reference counter - it counts how many references
exists to this memory region.   

User can request new buffer from memory pool with \func{TakeBuffer()} method. 
It returns \class{dabc::Buffer} instance with reference on the buffer of specified size.
To release buffer, one should call \func{dabc::Buffer::Release()} static method.  
 

\subsection{Buffer}
\label{prog_services_memory_buffer}
In general case \class{dabc::Buffer} contains list of segments (gather list) to different 
regions from the memory pool.
Segment (represented by \class{dabc::MemSegment}) contains unique buffer id, pointer
on segment begin and size of segment. Usually \class{dabc::Buffer} contains 
just one segment, which fully covers complete buffer from memory pool (for instance, 
when new buffer requested from the memory pool). Methods \func{NumSegments()} and
\func{Segment(unsigned)} provides access to list of segments. One can also directly access
pointer and size of each segment via \func{GetDataLocation(unsigned)} and \func{GetDataSize(unsigned)}
respectively. For instance, filling buffer with all zeros will look like this:  
 
\begin{small}
\begin{verbatim}     
#include "dabc/Buffer.h"

void UserModule::ProcessOutputEvent(dabc::Port* port)
{
   dabc::Buffer* buf = Pool()->TakeBuffer(2048);
   memset(buf->GetDataLocation(), 0, buf->GetDataSize());
   Output(0)->Send(buf);
}
\end{verbatim}     
\end{small}

One can always create reference to the same data, calling \func{MakeReference()} method.
This increments reference counter for all segments and returns pointer on
other \class{dabc::Buffer} instance with the same list of segments. This method used
when same data should be send over several ports - one just make as many reference 
as required and send them to all destinations independently without making copy of data.
For instance, simplified version of \func{dabc::Module::SendToAllOutputs} will look like:  

\begin{small}
\begin{verbatim}     
void dabc::Module::SendToAllOutputs(dabc::Buffer* buf)
{
   for(unsigned n=0;n<NumOutputs();n++)
      Output(n)->Send(buf->MakeReference());
   dabc::Buffer::Release(buf);
}
\end{verbatim}     
\end{small}


\class{dabc::Buffer} object has 32-bit type identifier, which can be set via
\func{SetTypeId()} method and retrieved with \func{GetTypeId()} method.
Its main aim - identify type of buffer content. Value of   
identifier is application specific - for instance, mbs plugin defines its own type,
which than used by transports to distinguish if buffer contains mbs event format.  

Each \class{dabc::Buffer} can be supplied with additional header. This is portion of 
memory, which is allocated and managed by pool separately from main memory and 
in generally \strong{should be} smaller than main buffer memory. 
Main idea to use buffer header is to add user-specific
information to already existing buffer without changing structure of buffer itself
(even not touch buffer id). 
Header size can be set by \func{SetHeaderSize()} method, pointer to header can be
obtained by \func{GetHeader()} method.
Main difference between header and the main memory - header content will be copied by 
the transport implementation when send via network. 


\subsection{Pointer}
\label{prog_services_memory_pointer}
Class \class{dabc::Pointer} provides seamless access to 
segmented data, which is referenced by \class{dabc::Buffer} object.
Using \class{dabc::Pointer}, one should not care how many segments 
referenced by buffer and how big they are. One can use following methods:
\bbul
\item[\func{Pointer()} or \func{reset()}]  reset pointer to \class{dabc::Buffer}, \class{dabc::Pointer} or just simple memory region   
\item[\func{ptr()} or \func{operator()}]   current memory pointer
\item[\func{rawsize()}]   size of contiguous memory from current pointer position  
\item[\func{fullsize()}]  size of full memory from current pointer position
\item[\func{shift()}]  shift pointer    
\item[\func{copyfrom()}]  set pointed memory from \class{dabc::Pointer} or just memory region
\item[\func{copyto()}]  copy pointed memory into specified memory region
\ebul   

Example of pointer usage:

\begin{small}
\begin{verbatim}     
#include "dabc/Buffer.h"
#include "dabc/Pointer.h"

void UserModule::ProcessOutputEvent(dabc::Port* port)
{
   if (!Input(0)->CanRecv()) return;
   dabc::Buffer* buf = Input(0)->Recv();
   dabc::Pointer ptr(buf);
   uint32_t v = 0; 
   while (ptr.fullsize()>0) {
      ptr.copyfrom(&v, sizeof(v));
      ptr.shift(sizeof(v));
      v++;
   }
   Output(0)->Send(buf);
}
\end{verbatim}     
\end{small}



\subsection{Buffer guard}

This is equivalent of lock guard in thread.
Class \class{dabc::BufferGuard} should be used to automatically release 
buffer when function scope is leaved - normally (by return) or abnormally 
(by exception). One should \strong{explicitly} take buffer from the guard
to avoid such automatic release in normal situation. Typical usage 
of \class{dabc::BufferGuard} shown here:

\begin{small}
\begin{verbatim}     
   ...
   dabc::BufferGuard buf = pool->TakeBuffer(2048);
   ...
   port->Send(buf.Take());
   ...
\end{verbatim}     
\end{small}

Class \class{dabc::ModuleSync} provides several methods to work directly 
with \class{dabc::BufferGuard} - this allows to correctly release buffer
in case of any exception, which may not handled correctly by user.  


\subsection{Allocation}

There are several methods, how memory pool can be created:
\bbul
\item Automatically, when user first time try to access it via pool handle 
\item using \func{dabc::Manager::CreateMemoryPool()} method
\item using \comm{dabc::CmdCreatePool} command
\ebul

Automatic creation is usefull for simple applications with few modules.
In this case parameters of pool handles (size and number of buffers) are used. 

But in many situations it is good to create memory pool explicitly,
setting all its parameters directly or via configuration file.
Typically memory pool is created by user application class in 
method \func{CreateAppModules()}, called by state change command \strong{DoConfigure}.
In simple case:

\begin{small}
\begin{verbatim}     
bool UserApplication::CreateAppModules()
{
   ...
   dabc::mgr()->CreateMemoryPool("WorkPool", 8192, 100);
   ...
}
\end{verbatim}     
\end{small}

One can call \func{CreateMemoryPool()} method several times to create 
block of memory for different buffers size. As alternative, one can create and 
configure \comm{dabc::CmdCreateMemoryPool}, where all possible settings can be 
done via following static methods:
\bbul
\item[\func{AddMem()}] add configuration for specified buffer size 
\item[\func{AddRef()}] add configuration for number of references and header sizes 
\item[\func{AddCfg()}] set generic configuratio like cleanup timeout or size limit 
\ebul

For instance, one can do following:

\begin{small}
\begin{verbatim}     
bool UserApplication::CreateAppModules()
{
   ...
   dabc::Command* cmd = new dabc::CmdCreateMemoryPool("WorkPool");
   dabc::CmdCreateMemoryPool::AddMem(cmd, 8192, 100);
   dabc::CmdCreateMemoryPool::AddMem(cmd, 2048, 500);
   dabc::CmdCreateMemoryPool::AddRef(cmd, 2048, 2000);
   dabc::CmdCreateMemoryPool::AddCfg(cmd, true); // set fixed layout
   dabc::mgr()->Execute(cmd);
   ...
}
\end{verbatim}     
\end{small}

All parameters, configured for the command, can be setup in configuration file.
In this case one should just call dabc::mgr()->CreateMemoryPool("WorkPool"). 


\section{Threads organization}
\label{prog_services_threads}
Class \class{dabc::WorkingThread} organizes working loop and performes execution of
runnable jobs, represented by \class{dabc::WorkingProcessor} class.


\subsection{Working loop}

Implementation of \class{dabc::WorkingThread} based on pthread library.
 
Main task of \class{dabc::WorkingThread} is to wait for events (using \func{pthread\_cond\_wait()} function)
and deliver events to correspondent processor. This functionality implemented 
in \func{dabc::WorkingThread::MainLoop()}.
 
Usually events are produced by calling \func{dabc::WorkingProcessor::FireEvent} 
method - this method can be invoked from any thread. Events are queued and 
pthread condition is fired in this case. Thread, waiting for condition is waked up and
event will be delivered to the processor by calling  \func{dabc::WorkingProcessor::ProcessEvent()}
virtual method. There any user-specific code can be implemented.

Another task of \class{dabc::WorkingThread} - timeout handling. Some of processors 
may require to be invoked not only by events, but also after specified time intervals.
Calling of method \func{dabc::WorkingProcessor::ActivateTimeout()} informs thread, that after
specified time interval thread should call \func{dabc::WorkingProcessor::ProcessTimeout()} method.  
 

\subsection{Sockets handling}

POSIX sockets library provides possibility to handle all sockets operations in 
event-like manner, using \func{select()} function. Such approach was used in  
\class{dabc::SocketThread} and \class{dabc::SocketProcessor} classes to provide
possibility handle several sockets in parallel from single thread.

With each \class{dabc::SocketProcessor} socket descriptor is associated, which can
deliver events like: can read next portion of data from socket, 
sending over socket will not blocked, socket is broken and so on.
Main loop of \class{dabc::SocketThread} modified so that instead of pthread condition waiting 
thread waits for next event from sockets.
Handling of these events allows to run sending/receiving of data via socket 
in non-blocking manner - means one can run several sockets operations in parallel.  

At the same time \class{dabc::SocketThread} class allows to run normal jobs,
implemented with base \class{dabc::WorkingProcessor} class. 
It means, within socket thread one can mix sockets processors (like transports) 
with normal processors (like modules).  

Similar approach was used for support of InfiniBand verbs API in \dabc. 


\subsection{Mutex usage}

All methods of \class{dabc::WorkingThread} and \class{dabc::WorkingProcessor} are thread
safe (excluding those started with underscore "\_" symbol). Therefore in
user code one could avoid use of mutexes completely. Only when data must be shared between
processors, runed in different threads, one should use mutexes. When mutex should be locked,
it is better to use \class{dabc::LockGuard}. This class guarantees that mutex will be always unlocked
when function scope is leaved. 

For instance, if one has global static variable and mutex, assigned with it,
one should implement setter method like this:
\begin{small}
\begin{verbatim}
#include "dabc/threads.h"

int GlobalVariable = 0;
dabc::Mutex GlobalMutex;

void SetGlobalVariable(int newvalue) 
{
   dabc::LockGuard guard(GlobalMutex);
   GlobalVariable = newvalue;
}
\end{verbatim}     
\end{small}


\section{Commands execution}
\label{prog_services_commands}

Idea of command execution is to be able invoke user-specific 
code from any part of the system. 
There are several reasons to use command interface instead of 
direct call of class methods:
\bbul
\item Execution of command performed not in context of calling thread but from thread, to which 
  object is assigned. This allows to avoids unnecessary locking.
\item Execution of command can be performed synchron or asynchron with calling thread, 
      therefore one can easily specify timeout for command execution. 
\item Command can be submitted to any object in the system, including objects on remote nodes.    
\item Class \class{dabc::Command} can contain arbitrary number of arguments 
      values and can be used for return of any number of result values.    
\ebul 

\subsection{Command class}

Class \class{dabc::Command} is container for argument and result values.
Name of the command is main identifier what should be done in command execution.

There are number of methods to set/get command parameters:

\begin{tabular}{l|l|l}
Type &  Getter & Setter  \\
   \hline
string  & GetStr() &  SetStr() \\
int  & GetInt() &  SetInt() \\
unsigned int  & GetUInt() &  SetUInt() \\
bool  & GetBool() &  SetBool() \\
double  & GetDouble() &  SetDoble() \\
\end{tabular}

In all setter methods first argument is name of command parameter and second is value
of correspondent type. In all getter methods first argument is again parameter name and
second is default parameter value (optional). Default value returned, when
parameter of that name was not specified in command. To instantiate command,
one should do: 

\begin{small}
\begin{verbatim}
...
dabc::Command* cmd = new dabc::Command("UserCommand");
cmd->SetInt("UserArg", 5);
...
\end{verbatim}     
\end{small}
   
Usually name of command defines action, which will be performed.
There are several subclasses of \class{dabc::Command} class (for instance, in
file "dabc/Manager.h"), but these subclasses only used to set command name and
command-specific parameters. There is no sense to define some extra methods
in subclass while \class{dabc::Command} object designed to be only a container for 
parameters.

With method \func{ConvertToString()} one can convert command and all its parameters in
the plain string. Method \func{ReadFromString()} is used to reconstruct command object
for string.     


\subsection{Command receiver}

Class \class{dabc::CommandReceiver} provides interface for classes, where command should be
executed. Main place for user code is virtual method \func{ExecuteCommand()}, which gets command 
object as argument. Typicall implementation of this method looks like:

\begin{small}
\begin{verbatim}
int UserModule::ExecuteCommand(dabc::Command* cmd)
{
   if (cmd->IsName("UserCommand")) {
      int v = cmd->GetInt("UserArg", 0);
      DOUT1(("Execute UserCommand with argument = %d", v));
      return dabc::cmd_true;
   } else
   if (cmd->IsName("UserGetCommand")) {
      DOUT1(("Execute UserGetCommand without arguments"));
      cmd->SetInt("UserRes", fCounter);
      return dabc::cmd_true;
   } 
      
   return dabc::ModuleAsync::ExecuteCommand(cmd);
}
\end{verbatim}     
\end{small}
 
In \func{ExecuteCommand} method one should analyse command name and perform command-specific
actions. Method should return \keyw{dabc::cmd\_true} when command executed 
succesfully or \keyw{dabc::cmd\_false} otherwise.  

Default implementation of \class{dabc::CommandReceiver} methods performs command execution
in the calling thread. Class \class{dabc::WorkingProcessor} inherites from \class{dabc::CommandReceiver}
and implements several virtual methods (like \func{IsExecutionThread()}, \func{IsExecutionThread(Submit())}) 
which are necessary to deliver and execute command in correct thread context.
User \strong{should not} reimplement these methods again in derived classes.
In inherited from \class{dabc::WorkingProcessor} classes like \class{dabc::Module}, \class{dabc::Application}
custom commands will be executed in appropriate thread context.  

With method \func{Execute()} of class \class{dabc::CommandReceiver} one can execute 
command directly in the object. One can specify \class{dabc::Command} object as argument
or just command name, if command has no arguments. Method \func{Execute()} will block
until command is executed - one says about \strong{synchron} mode of command execution. 
Optionally one can set timeout - how long calling thread will wait until command is executed. 

Method \func{Execute()} only usefull to check if command executed succesfully or not -
one has only boolean return value. There are advanced methods \func{ExecuteInt()} and
\func{ExecuteStr()} which allows to return result of command execution as integer or string value.
For example, result of command "UserGetCommand" execution from previous example one can
obtain so:  

\begin{small}
\begin{verbatim}
...
dabc::Module* m = dabc::mgr()->FindModule("Module1");
int res = m->ExecuteInt("UserGetCommand", "UserRes");
...
\end{verbatim}     
\end{small}


There is other way to execute command - submit command with \func{Submit()} method.
In this case command will be exeuted \strong{asynchron} to the calling thread, therefore
one cannot get any information about result of command execution.


\subsection{Command client}

To really use asynchron way of command execution, one should be able analyse result
of such commands execution. This can be done with \class{dabc::CommandClient}.
Commands, before submited for execution, should be assigned to \class{dabc::CommandClient} object.
In this case, client get callback from command when execution is done and can react on this callback.
One can assign more than one command to the client.

First example of client usage - if one need to execute many commands at once.
If one use \func{Execute()} method, all commands can be only executed \strong{sequentially}.
If one uses command client, one able first submit many commands and than wait that all
of them are executed. If objects, where commands should be executed, runs in different threads,
commands will be executed in \strong{parallel}. For instance:

\begin{small}
\begin{verbatim}
...
dabc::CommandClient cli;
for (unsigned n=0; n<10; n++) {
   dabc::Module* m = dabc::mgr()->FindModule(FORMAT(("Module%u",n)));
   dabc::Command* cmd = new dabc::Command("UserCommand");
   cli.Assign(cmd);
   m->Submit(cmd);
}
bool res = cli.WaitCommands();
...
\end{verbatim}     
\end{small}
  
Here one submits 10 commands into 10 different modules and waits in one place until commands are executed.

Another use of command client - keep command object after command is executed to be able
analyse its return values. For instance, all 10 commands from previous example may 
return several values each. If one instantiate client with "true" as contructor argument,
at the end all commands will be avalible via \func{ReplyedCmds()} method. 


\begin{small}
\begin{verbatim}
...
dabc::CommandClient cli(true);
...
bool res = cli.WaitCommands();
DOUT1(("One has %u commands in replyed queue", cli.ReplyedCmds().Size()));
...
\end{verbatim}     
\end{small}


One more use of command client interface - is \class{dabc::CommandsSet}. 
It inherits from \class{dabc::CommandClientBase} - abstract base class for commands clients. 
It useful in the case when execution of some master command should cause execution of several
other commands. For instance, when execution of command 
in one module should be distributed on two other modules, one should do:

   
\begin{small}
\begin{verbatim}
int UserModule::ExecuteCommand(dabc::Command* cmd)
{
   if (cmd->IsName("MasterCommand")) {
      dabc::CommandsSet* set = new dabc::CommandsSet(cmd);
      
      dabc::Module* m1 = dabc::mgr()->FindModule("Module1");
      m1->Submit(set->Assign(new dabc::Command("UserCommand1")); 

      dabc::Module* m2 = dabc::mgr()->FindModule("Module2");
      m2->Submit(set->Assign(new dabc::Command("UserCommand2")); 

      dabc::CommandsSet::Completed(set, 10.);
      
      return dabc::cmd_postponed;
   } 
      
   return dabc::ModuleAsync::ExecuteCommand(cmd);
}
\end{verbatim}     
\end{small}

Here one create set for "master" command and submit two "slave" commands via client
to two other modules. Method \func{dabc::CommandsSet::Completed} used to inform framework
that all commands are submitted and they should be ready in 10 seconds. Return argument
\keyw{dabc::cmd\_postponed} indicates that master command may not be ready at moment, when method is returned.
Therefore \class{dabc::CommandsSet} will takes care about correct reply of master command when
either all slaves are ready or timeout is expire.








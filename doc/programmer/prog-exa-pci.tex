[programmer/prog-exa-pci.tex]

\section{Overview}
Reading data streams from a PCI board into the PC is a common use case
for data acquisiton systems. In \dabc~ one can implement access to
such boards by means of special \class{Device} and \class{Transport}
classes that communicate with the appropriate linux device driver.
The \class{Device} represents the board and may do the hardware set-up 
at \keyw{Configure} time, using dedicated \class{dabc::Parameters}. 
The \class{Transport} may fill its data buffers via board DMA, and
pass the \class{Buffers} to the connected readout \class{Module}. 

This example treats the
\strong{Active Buffer Board} (\ABB) \cite{AbbDescription}, 
a PCI express (PCIe) board with a {\em Virtex 4}
FPGA and optical connectors to receive data from the experiment frontend
hardware. It is developed for the CBM experiment \cite{CBM-stat-rep}
by the {\em Institut f. Technische Informatik} at Mannheim University. 
The board developers deliver a kernel module as linux device driver,
and the \class{mprace::} C++ library to work with the board from user space.

Since this driver software may also be applied for other PCIe boards,
the corresponding \dabc~ classes \class{pci::Device} and \class{pci::Transport}
are rather generic, using namespace \class{pci::}.
The special properties of the \ABB board are then implemented in
a \class{pci::BoardDevice} subclass and in further classes with namespace
\class{abb::}. 

Besides some simple test executables that read from and write to the 
\ABB on a single machine, there is an example of a \class{bnet::WorkerApplication}
that applies the \ABB classes for the readout module.    
 


\section{PCI Device and Transport}


\subsection{pci::BoardDevice}
Subclass of \class{dabc::Device}. Adapter to the the \class{mprace::Board} functionality, i.e. the generic PCIe.

\begin{compactenum} 

\item It implements the \strong{Transport factory method} \func{CreateTransport()}. 
This will create a \class{pci::Transport} and assign a dedicated working thread 
for each transport. The \dabc~ framework will use this method to establish
the data connection of a \class{Port} with the PCI device.

\item It defines a \strong{plug-in point} for an abstract board component:
The device functionalities may require driver implementations that are more
board specific. Because of this, the \class{mprace::} library
provides base class \class{Board} with some virtual methods to work on the
driver. This is applied here as handle to the actual \class{Board} 
implementation (e.~g.~ a \class{mprace:ABB})
that must be instantiated in the constructor of the
subclass. Note that all functionalites require a
real \class{Board} implementation, thus it is not possible
to instantiate a mere \class{pci::BoardDevice} without subclassing it! 

\item It adds \strong{Device specific commands}  
\class{CommandSetPCIReadRegion} and
\class{CommandSetPCIWriteRegion} that define the regions in
the PCI address space for reading or writing data, resp.
Method \func{ExecuteCommand(Command*)} is extended 
to handle such commands. 

\item It manages the \strong{scatter-gather mapping} of userspace 
\class{dabc::Buffer} objects for the DMA engine.
These are taken from a regular \dabc memory pool
and are each mapped to a \class{mprace::DMABuffer} representation. 
The DMA mapping is done  
in method \func{MapDMABuffer()} which gets the reference to 
the \class{dabc::MemoryPool*} that is used for the \class{pci::Transport}. 
This is required at \class{Device} initialization time; 
the mapping must be refreshed 
on the fly if the memory pool changes though.

Method \func{GetDMABuffer(dabc::Buffer*)} 
will deliver for each \class{dabc::Buffer*} of the mapped memory pool 
the corresponding \class{mprace::DMABuffer*} object to be used in the
underlying \class{mprace::} library. These are associated by the 
\class{dabc::Buffer} id number which defines 
the index in the \class{std::vector} keeping the \class{mprace::DMABuffer*}
handles. 

Method \func{DoDeviceCleanup()} is implemented for 
a proper cleanup of the mapped DMA buffers when the \class{Device}
is removed by the framework.



\item \strong{Reading data from the board:}
Method \func{ReadPCI(dabc::Buffer*)} 
implements reading one buffer from PCI, using the BAR,
the PCI start address, and the read size, as specified before.
These read parameters may be either set by method 
\func{SetReadBuffer(unsigned int bar, unsigned int address, unsigned int length)},
or by submitting the corresponding command \class{CommandSetPCIReadRegion} to 
the \class{pci::Device}
    
If DMA mode (defined in the constructor) \strong{is not} enabled , 
this will just use PIO to fill the specified 
\class{dabc::Buffer} from the PCI address range.
If DMA mode \strong{is} enabled, it will
perform DMA into the user space \class{dabc::Buffer*}; this must be taken from a memory pool
that was mapped before by means of \func{MapDMABuffer()}.
This is a synchronous call that will initiate the DMA transfer 
and block until it is complete.
 
For asynchronous DMA (double buffering of \class{dabc::DataTransport}) 
following virtual methods are provided:
Method \func{ReadPCIStart(dabc::Buffer*)} may start 
the asynchronous filling of one mapped \class{Buffer} from the configured PCI 
board addresses. It should not wait for the completion of the data transfer, but
return immeadiately without blocking after triggering the DMA. In contrast to this,
\func{ReadPCIComplete(dabc::Buffer*)} must 
wait until the DMA transfer into the specified \class{Buffer} is completely
finished. So the \class{pci::Transport} will initiate DMA 
by \func{ReadPCIStart()} and
check for DMA completion by \func{ReadPCIComplete()}.
A subclass of \class{pci::BoardDevice}
may re-implement these methods with board specific functionalities.


\item \strong{Writing data to the board:}
Method \func{WritePCI(dabc::Buffer*)} 
implements writing data from a \dabc~ buffer to the PCI address space, 
using the BAR, the PCI start address, and the write size, as specified before.
These write parameters may be either set by method 
\func{SetWriteBuffer(unsigned int bar, unsigned int address, unsigned int length)},
or by submitting the corresponding command \class{CommandSetPCIWriteRegion} to 
the \class{pci::Device}.
If DMA mode (defined in the constructor) \strong{is not} enabled , 
this will just use PIO to transfer the specified 
\class{dabc::Buffer} to the PCI addresses.

If DMA mode \strong{is} enabled, it will
perform DMA from the user space \class{dabc::Buffer*}; this must be taken from a memory pool
that was mapped before by means of \func{MapDMABuffer()}. 
This call will initiate the DMA transfer and block until it is complete.
Currently there is no asynchronous implementation for data output to PCI,
since this is a rare use case for a DAQ system.


\end{compactenum} 


\subsection{pci::Transport}
This class handles the connection between
the \class{Port} of a module and the PCI device.
It is created in \func{CreateTransport()} of \class{pci::BoardDevice}
when the user application calls the corresponding \class{Manager}
method with the names of the port and the device instances, e.~g.~ \\
{\tt dabc::mgr()->CreateTransport("ReadoutModule/Input", "AbbDevice3");}

It extends the base class \class{dabc::DataTransport} which already provides
generic \class{Buffer} queues with a data backpressure mechanism, 
both for input and output direction. 
Because this class is also a \class{WorkingProcessor},
each \class{pci::Transport} object has a  dedicated thread that runs
the IO actions.
The following virtual methods of \class{dabc::DataTransport} were implemented:

 \begin{description} 


\item[\em unsigned Read\_Size()] :
Returns the size in byte of the next buffer that is to be read from board. 
Uses the current readout length as set for the \class{pci::BoardDevice}
with \func{SetReadBuffer()}, or \class{CommandSetPCIReadRegion}, resp.

\item[\em unsigned Read\_Start(dabc::Buffer* buf)] :
This initiates the reading into buffer \func{buf} and returns
without waiting for completion. The functionality is
forwarded to \func{ReadPCIStart()} of \class{pci::BoardDevice}. 
When \func{Read\_Start()} returns, the transport thread
can already push the \strong{previously} filled DMA buffer 
to the connected \class{Port}, 
which may wake up the waiting thread of its \class{Module} for further
processing. Thus base class \class{dabc::DataTransport} 
implicitly provides a double-buffering mechanism here.

\item[\em unsigned Read\_Complete(dabc::Buffer* buf)] :
Will wait until filling the buffer \func{buf} from a DMA read operation
is completed. The DMA either must have been started asynchronously 
by a previous \func{Read\_Start()} call; or it must be started 
synchronously here.
This method is used by the base class for synchronization
between transport thread and DMA engine of the PCI board. 
The functionality is forwarded to \func{ReadPCIComplete()} 
of \class{pci::BoardDevice}. 


\item[\em bool WriteBuffer(dabc::Buffer* buf)] :
Write content of \func{buf} to the PCI region 
as set for the \class{pci::BoardDevice}
with \func{SetWriteBuffer()}, or \class{CommandSetPCIWriteRegion}, resp.
This is a pure synchronous method, i.~e.~ it will start the DMA
transfer and return no sooner than it's completed.
The functionality is forwarded to \func{WritePCI()} 
of \class{pci::BoardDevice}. 

\item[\em void ProcessPoolChanged(dabc::MemoryPool* pool)] :
Is called by the framework whenever the memory pool associated with the 
transport instance changes, e.~g.~ at transport connection time, 
pool expansion, etc. It calls \func{MapDMABuffers()} 
of \class{pci::BoardDevice}
to rebuild the scatter-gather mappings for each buffer of the pool.


\end{description} 

\section{Active Buffer Board implementation}

\subsection{abb::Device}
This subclass of \class{pci::BoardDevice} adds some functionality that is
rather specific to the \ABB hardware and the test environment.


\begin{compactenum} 

\item It Exports \class{Parameters} for the \strong{board configuration}:
here list of paramteter examples

\item The constructor instantiates the \class{mprace::Board} component for the
\ABB functionalities. Additionally, a DMA engine component
\class{mprace::DMAEngineWG} is applied for all DMA specific actions.

\item It implements the actual asynchronous DMA by overriding 
methods \func{ReadPCIStart()} and \func{ReadPCIComplete()}.
The base class \class{pci::BoardDevice}
can provide the synchronous DMA only, because
the generic \class{Board} interface of the \class{mprace::}
library does not cover asynchronous features.
These are handled by the \class{DMAEngineWG} component.

\item It provides  \strong{pseudo event data} for the Bnet test example in the 
received DMA buffers: 
Method \func{ReadPCI()} is extended to copy an event header of the Bnet format (i.e. incrementing event count and unique id) into each output Buffer after the base class \func{ReadPCI()} is complete. This workaround is necessary since the \ABB
data itself does not contain any information in the test setup.
Additionally, method \func{DoDeviceCleanup()} will reset the event counters
at the end of each DAQ run. 


\end{compactenum} 

\subsection{abb::ReadoutModule}
Subclass of \class{dabc::ModuleAsync}; generic implementation of a readout module to use the \class{pci::BoardDevice}.

\begin{compactenum} 
\item Creates the memory pool which is used for DMA buffers in the \class{PCIBoardDevice}; this pool is propagated to the device via the \class{PCITransport} when module is connected, since device will use the pool associated with the connection port.
\item Module runs either in standalone mode (one input port, no output) for testing; or in regular mode (one input port, one output port)
\item \func{ProcessUserEvent()} defines the module action for any dabc events, e.g. input port has new buffer. In standalone mode, received buffer is just released. In regular mode, buffer is send to the output port.
\end{compactenum} 

\subsection{abb::WriterModule}
Subclass of \class{dabc::ModuleSync}; generic implementation of a writer module to use the \class{pci::BoardDevice}.
\begin{compactenum} 

\item Creates the memory pool which is used for DMA buffers in the \class{PCIBoardDevice}; this pool is propagated to the device via the \class{PCITransport} when module is connected, since device will use the pool associated with the connection port.
\item Module runs either in standalone mode (one output port, no input) for testing; or in regular mode (one input port, one output port)
\item \func{MainLoop()} defines the module action. In standalone mode, a new buffer is taken from the memory pool and send to the output port. In regular mode, the send buffer is taken from the input port.

\end{compactenum} 

\subsection{abb::Factory}
Subclass of \class{dabc::Factory}. Generic plugin to utilize ABB classes in a set up:
\begin{compactenum} 

\item Implements \func{CreateDevice()} for the \class{abb::Device}. Third argument of this factory method is \class{dabc::Command}, containing initial setup parameters of the device.
\item Implements \func{CreateModule()} for the \class{abb::ReadoutModule} and the \class{abb::WriterModule}. Third argument of this factory method is \class{dabc::Command}, containing initial setup parameters of the module.
\item Factory is created automatically as static (singleton) instance on loading the \verba{libDabcAbb.so}.

\end{compactenum} 

%See Class Diagram of dabc PCI classes.


\section{Simple read and write test}


\section{Active Buffer Board with Bnet application}
The \class{TestWorkerPlugin} of the bnet/test example was modified to optionally integrate ABB.

\subsection{bnet::TestWorkerApplication}
Subclass of \class{bnet::WorkerApplication}. This example has possibililty to utilize ABB classes in a bnet-set up.

\begin{compactenum} 

\item Registers parameters to configure the ABB. Note: The Parameter names are defined as string constants in \decl{AbbFactory.h}. These same names are used by \class{AbbFactory} methods to get the appropriate command parameters!
\item Implements \func{CreateReadout()} with optional \class{AbbDevice}. May either use the \class{AbbDevice}, or still use the \class{TestGeneratorModule} of the example. This is switched by configuration parameter via the \func{ReadoutPar()} value (either "ABB", or anything else).Connects \class{AbbDevice} directly with the input port of the combiner module; we do not use \class{dabc::AbbReadoutModule} here (this is applied for standalone example \verba{abb\_test} only).

\end{compactenum} 

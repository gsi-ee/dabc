[programmer/prog-plugin.tex]
\section{Introduction}
A multi purpose DAQ system like \dabc~ requires to develop user specific code and adopt
this into the general framework. A common object oriented technique to realize such
extensibility consists in the definition of base classes as interfaces for dedicated purposes.
The programmer may implement subclasses for these interfaces as \strong{Plug-Ins}
with the extended functionality that matches the data format, hardware, or other boundary conditions of the
data-taking experiment. Moreover, the  \dabc~ core itself applies such powerful plug-in mechanism to provide 
generic services in a flexible and maintainable manner.   

This chapter gives a brief description of all interface classes for the data acquisition 
processing itself. This covers the processing \strong{Modules}, the \strong{Transport} and 
\strong{Device} objects that move data between the DAQ components, 
and the \strong{Application} that is responsible for the node set-up and run control.
A \strong{Factory} pattern is used to introduce new classes to the framework and let them
be available by name at runtime.


\section{Modules}

\dabc~ provides \class{dabc::Module} class, which plays role of data processing entity in framework. 
In this class necessary components like pool handles, ports, parameters, timers are organised.
Class \class{dabc::Module} has two subclasses - \class{dabc::ModuleSync} and \class{dabc::ModuleAsync},
which provides two different paradigms of data processing: within explicit main loop and via event processing respectively.
Before discuss these two kinds of modules, lets consider components, which can be used with both types 
of the module.


\subsection{Pool handles}

Class \class{dabc::PoolHanlde} should be used in any module to communicate with \class{dabc::MemoryPool}.
By creating pool handle with method \func{CreatePoolHandle}, module declares that it 
wants to use buffers from specified (by name) memory pool. 
More than one memory handle can be used in one module. 
Pool handle can be accessed with method \func{dabc::Module::FindPool} via name or
with method \func{dabc::Module::Pool} via handle number (started from 0).

When pool with given name not exists, it will be created automatically at the 
time of first request. In this case plays a role buffer size and number of buffers,
which are specified in \func{CreatePoolHandle} call. 


\subsection{Ports}

Class \class{dabc::Port} is the only legal way to transport buffers from/to the module.
Class \class{dabc::Module} provides following methods for working with ports:

\begin{tabular}{|l|l|ll|l|}
   \hline
kind &  Create  & Count & Access & Search \\
   \hline
input   & \func{CreateInput(name, ...)} & \func{NumInputs()} & \func{Input(unsigned)} & \func{InputNumber()} \\
output  & \func{CreateOutput(name, ...)} & \func{NumOutputs()} & \func{Output(unsigned)} & \func{OutputNumber()} \\
inp/out  & \func{CreateIOPort(name, ...)} & \func{NumIOPorts()} & \func{IOPort(unsigned)} & \func{IOPortNumber()} \\
   \hline
\end{tabular}

Port usually should be created in module constructor.
As first argument in creation methods unique port name should be specified.
As second argument, pool handle should be
specified - it defines pool where necessary memory can be fetched for transports, 
associated with the port. Length of input or (and) output queue defines how many
buffers can be kept in correspondent queue. One also can specify size of user header,
which is expected to be transported over the port - it is important for further transport configurations.    

Any kind of port can be found by name with \func{FindPort()} method.
But this is not the fastest way to work with ports, while string search is not
very efficient. 
One better should use in code methods like func{NumInputs()} and \func{Input(unsigned)} (for input ports),
where port sequence number is used. 

Class \class{dabc::Port} provides methods \func{Send()} and \func{Recv()} to send or receive buffers. 
While these are non-blocking methods, one should use \func{CanSend()} and \func{CanRecv()} methods 
before one can call transfer operations.


\subsection{Parameters and configurations}

Parameters are used in module for configuration, controlling and monitoring.
More information about parameters handling see in chapter ...


\subsection{Commands processing}

There is possibility in \dabc~ to execute user-defined commands in module context.
Virtual method \func{ExecuteCommand} called every time when new command is submitted
to the module. Command \strong{always} executed in module thread disregard from which thread
command was submitted, therefore it is not necessary to lock command execution code.
Most actions in \dabc~ performed with help of the commands. 

Possible example how command execution can look like:
\begin{small}
\begin{verbatim}
int UserModule::ExecuteCommand(dabc::Command* cmd) 
{
   if (cmd->IsName("UserPrint")) {
      DOUT1(("Printout from UserModule"));
      return dabc::cmd_true;
   }
   return dabc::ModuleSync::ExecuteCommand(cmd);
}
\end{verbatim}
\end{small}

Than somewhere in the code of other component:
\begin{small}
\begin{verbatim}
...
dabc::Module* m = dabc::mgr()->FindModule("MyModule"); 
dabc::Command* cmd = new dabc::Command("UserPrint");
m->Execute(cmd);
// again, but in short form
m->Execute("UserPrint");
...
\end{verbatim}
\end{small}
Method \func{Execute} returns true when command executed successfully. 
When command is executed, \class{dabc::Command} object deleted automatically.  

One can register command in module constructor. In this case command will be 
known by control system and can be invoked by user from the GUI:

\begin{small}
\begin{verbatim}
UserModule::UserModule(const char* name) : dabc::ModuleSync(name) 
{
   ...
   dabc::CommandDefinition* def = NewCmdDef("UserPrint");
   def->AddArgument("Level", dabc::argInt, false); // optional argument
   def->Register(true);
}
\end{verbatim}
\end{small}


\subsection{ModuleSync}
\index{Core classes !dabc::ModuleSync}
\label{plugin_module_sync}
Data processing functionality in most intuitive way can be implemented by subclassing 
the \class{dabc::ModuleSync} base class, which defines the interface for a 
synchronous module that is allowed to block its dedicated execution thread.  

Class provides a number of methods, which are blocked until expected action 
cannot be performed.

\begin{tabular}{ll}
Method &  Description \\
   \hline
\func{Recv()} & Receive buffer from specified input port \\
\func{Send()} & Send buffers over output port \\
\func{RecvFromAny()} & Receive buffer from any of specified port \\
\func{WaitInput()} & Waits until required number of buffers is queued in input port \\
\func{TakeBuffer()} & Get buffer of specified size from memory pool \\
\func{WaitConnect()} & Waits until port is connected \\
   \hline
\end{tabular}

In all these methods timeout value as last argument can be specified.
Method \func{SetTmoutExcept} defines if \class{dabc::TimeoutException} exception 
is produced when timeout is expired. By default, these blocking methods
just return false in case of timeout.

Data processing should be implemented in \func{MainLoop()} method.
It usually contains \strong{while} loop where \func{ModuleWorking()} method
is used to check if execution of module code shall be continued.
This method is also used to execute queued command if user specified
so-call synchronous command execution by \func{SetSyncCommands()} call.
By default, command can be executed in any place of the code. 

Lets consider simple example of the module, 
which has one input and two output ports and deliver buffers from input to
one or another output sequentially. Implementation of such 
class will look like:
\begin{small}
\begin{verbatim}
#include "dabc/ModuleSync.h"

class RepeaterSync : public dabc::ModuleSync {
public:
   RepeaterSync(const char* name) : dabc::ModuleSync(name)
   {
      CreatePoolHandle("Pool", 2048, 1);
      CreateInput("Input", Pool(), 5);
      CreateOutput("Output0", Pool(), 5);
      CreateOutput("Output1", Pool(), 5);
   }
     
   virtual void MainLoop()
   {
      unsigned cnt(0);
      while (ModuleWorking()) {
         dabc::Buffer* buf = Recv(Input());
         if (cnt++ % 2 == 0) Send(Output(0), buf);
                        else Send(Output(1), buf);
   }
};
\end{verbatim}
\end{small}

In constructor one sees creation of pool handle and input and output ports.
Method \func{MainLoop} has simple while loop, where buffer received from the
input and than send to first or second output.

  
\subsection{ModuleAsync}
\index{Core classes !dabc::ModuleAsync}
\label{plugin_module_async}

In contrast to data processing in \class{dabc::ModuleSync} main loop,
class \class{dabc::ModuleAsync} provides 
number of callbacks routines which are executed only if dedicated \dabc~ events occurs.
For instance, when any input port gets new buffer, virtual method \func{ProcessInputEvent} will
be called. User should reimplement this method to react on the event.

Main advantage of such approach that thread is not blocked and
several modules \class{dabc::ModuleAsync} can run within same working thread.
At the same time, using such programming technique may requires additional 
bookkeeping while it is not allowed to block callback routine, waiting that
some resource is available.

Class \class{dabc::ModuleSync} provides number of methods for handling different events:

\begin{tabular}{ll}
Method &  Description \\
   \hline
\func{ProcessInputEvent()} & new buffer in input queue, it can be read with port->Recv() \\
\func{ProcessOutputEvent()} & new place in output queue is availible, one can use port->Send()  \\
\func{ProcessConnectEvent()} & port is connected to transport  \\
\func{ProcessDisconnectEvent()} & port was disconnected from transport  \\
\func{ProcessPoolEvent()} & requested buffer can be read with handle->TakeRequestedBuffer()  \\
\func{ProcessTimerEvent()} & time has fired and event  \\
\end{tabular}

By reimplementing one or several from these methods, one can react on correspondent events.

Actually, all events are dispatched to the mentioned above metyhods by method 
\func{ProcessUserEvent()}. 
The method called by the working thread
whenever {\bf any} event for this module shall be processed.
However, this virtual method  
may also directly be re-implemented in the user subclass
if one wants to treat all events centrally. 
As arguments one get component pointer (port, timer, ...) and number of
event type (dabc::evntInput, dabc::evntOutput, ...) 
 
Class \class{dabc::ModuleAsync} has no methods, which can block thread.
Nevertheless user should avoid any kind of polling loops, waiting for some
other resource (buffer, output queue and so on) - callbacks should \strong{return}
as soon as possible. In such situation processing can be continued in 
the other callback, called when required resource is available. 
This might require an own bookkeeping of such situations (kind of state transition logic). 

Lets consider as an example same repeater module, but implemented with asynchronous module.
   
\begin{small}
\begin{verbatim}
#include "dabc/ModuleAsync.h"
#include "dabc/Port.h"

class RepeaterAsync : public dabc::ModuleAsync {
   unsigned   fCnt;
public:
   RepeaterAsync(const char* name) : dabc::ModuleAsync(name)
   {
      CreatePoolHandle("Pool", 2048, 1);
      CreateInput("Input", Pool(), 5);
      CreateOutput("Output0", Pool(), 5);
      CreateOutput("Output1", Pool(), 5);
      fCnt = 0;
   }
    
   virtual void ProcessInputEvent(dabc::Port* port) 
   {
      while (Input()->CanRecv() && Output(fCnt % 2)->CanSend()) {
         dabc::Buffer* buf = Input()->Recv();
         Output(fCnt++ % 2)->Send(buf);
      }
   }

   virtual void ProcessOutputEvent(dabc::Port* port) 
   {
      while (Input()->CanRecv() && Output(fCnt % 2)->CanSend()) {
         dabc::Buffer* buf = Input()->Recv();
         Output(fCnt++ % 2)->Send(buf);
      }
   }
};
\end{verbatim}
\end{small}

Constructor of this module has absolutely the same components as in previous example.
One should add \member{fCnt} member to count direction for output of next buffer.
Value of \member{fCnt} in some sense defines current state of the module. 
 Instaed of main loop one can see two virtual methods for input and output event
processing. In each methods one sees same code, with while loop inside.
In the loop one checks that input and current output are ready and retransmit buffer.
When any port (input or output) has no more possibility to transmit data, 
method will be returned. 

One need \keyw{while} loop here while not every input event and not every output events
leads to buffer transports. In case, when input queue is empty (\func{CanRecv} returns false) 
or output queue is full (\func{CanSend} returns false) one cannot transfer buffer from input
to output, therefore callback must be returned. But next time event processing routine is
called, one should tranfer several buffers at once. While methods \func{Send} and \func{Recv}  
cannot block, such \keyw{while} loop will not block too. But in any case one should 
avoid such \strong{wrong} code:

\begin{small}
\begin{verbatim}
   virtual void ProcessInputEvent(dabc::Port* port) 
   {
      // this kind of waiting is WRONG!!!
      while(!Output(fCnt % 2)->CanSend()) usleep(10);
   
      dabc::Buffer* buf = Input()->Recv();
      Output(fCnt++ % 2)->Send(buf);
   }

\end{verbatim}
\end{small}

Here \keyw{while} loop can wait infinite time until output port will accept new buffer
and during this time complete thread will be blocked. 

While both processing methods are the same in the example,  
one can implement central \func{ProcessUserEvent} method instead:  
 
\begin{small}
\begin{verbatim}
   virtual void ProcessUserEvent(dabc::ModuleItem*, uint16_t)
   {
      while (Input()->CanRecv() && Output(fCnt % 2)->CanSend()) {
         dabc::Buffer* buf = Input()->Recv();
         Output(fCnt++ % 2)->Send(buf);
      }
   }
\end{verbatim}
\end{small}

To introduce time-dependent activity in \class{dabc::ModuleAsync}, 
one should use timers. Timer object can be created with method 
\func{CreateTimer}. It delivers timer event with specified intervals, 
which can be processed in \func{ProcessTimerEvent()} method.

One can modify previos example to display number of transported buffers
every 5 seconds.

\begin{small}
\begin{verbatim}
   RepeaterAsync(const char* name) : dabc::ModuleAsync(name)
   {
      ...
      CreateTimer("Timer1", 5.);
   }

   virtual void ProcessUserEvent(dabc::ModuleItem* item, uint16_t evnt)
   {
      ...
      if (evnt == dabc::evntTimeout) DOUT1(("Buffers count = %d", fCnt));  
   }
\end{verbatim}
\end{small}
   

\subsection{Special modules}
For special set ups (e.g. Bnet), the framework provides 
   \class{dabc::Module} subclasses with generic functionality 
   (e.g. \class{bnet::BuilderModule}, \class{bnet::FilterModule}). 
   In this case, the user specific parts like data formats are 
   implemented by subclassing these special module classes.

   
\begin{compactenum}

\item  Instead of implementing \func{MainLoop()}, other virtual 
      methods (e.g. \func{DoBuildEvent()}, \func{TestBuffer()}) may be 
      implemented that are implicitly called by the superclass \func{MainLoop()}.
\item  The special base classes may provide additional 
      methods to be used for data processing.    
\end{compactenum}

\section{Device and transport}
\label{prog_plugin_device}
All data transport functionality is implemented by 
   subclassing  \class{dabc::Device} and \class{dabc::Transport} base classes.
       
\begin{compactenum}
\item  The \class{dabc::Device} subclass constructor may create  
      pool handles and may define commands and parameters. 

\item  Method \func{int CreateTransport(Command* cmd, Port* port)} of the \class{dabc::Device}
      implementation creates the appropriate \class{dabc::Transport} 
      instance and connects it to the given \func{Port* port}.
      It is invoked by the framework  when this device is connected to 
      a module port, which is usually specified in the application via calls
      of \class{dabc::Manager} methods. The optional argument 
      \func{Command* cmd} may pass further parameters from the application 
      to the new transport, encapsulated in a command object. 
      
% \item  The virtual \func{bool Send(Buffer* buf)} and \func{bool Recv(Buffer* \&buf)} methods of the 
%       \class{dabc::Transport} subclass must implement the actual transport 
%       from and to a connected port, respectively.

\item  The special transport class \class{dabc::DataTransport} 
(inherits from \class{dabc::Transport})
       should be used as base class to implement a user defined transport 
      (e.~g.~ read from a user defined hardware board).
      This class already provides queues for (optionally)
      input and output buffers and a data backpressure mechanism. 
      The user subclass must implement virtual methods 
      to perform the data transport which are called implicitely from 
      the framework at the right time:
\begin{compactdesc}
	
	\item [\func{unsigned Read\_Size()}] : 
	Should specify the required buffer size to be read from the device, 
	e.~g.~ the DMA memory size. Framework will then allocate a \func{Buffer}
	of appropriate size for the \func{Read\_*} functions

	\item [\func{unsigned Read\_Start(Buffer* buf)}] : transport gets a 
	\func{Buffer* buf} to be filled in the read. Actual filling may be done
	asynchronously to the calling thread, e.~g.~ by DMA. Thus
	this function may initiate the asynchronous read here and return
	immeadeately before the read is complete. 
	For synchronous filling of the buffer, this function should do nothing.
	
	
	\item [\func{unsigned Read\_Complete(Buffer* buf)}] :
	Called before the framework transfers the \func{Buffer* buf}
	to the connected port. The transport should no sooner return this function
	 than the reading of this buffer (e.~g.~ by DMA) 
	 is complete. In case of synchronous reading, the buffer filling is also
	 initiated here. For asynchronous reading, 
	 buffer filling has been initiated before
	 in func{unsigned Read\_Start(Buffer* buf)} and this function just waits
	 for a "buffer complete" state from the filling device.
      
	\item [\func{void Read\_CallBack(unsigned compl\_res = DataInput::di\_Ok)}] :
	this method MUST be called by transport when \func{Read\_Start()} 
	returns \func{di\_CallBack}. It is only way to "restart" event loop in the transport (Sergei, please explain more!)
	
	\item [\func{double Read\_Timeout()}] :
	Defines timeout for operation in ms? TO BE EXPLAINED
	
	\item [\func{bool WriteBuffer(Buffer* buf)}] : 
	The arriving \func{Buffer* buf} is synchronously written to the device.	
         
	\item [\func{void ProcessPoolChanged(MemoryPool* pool)}] : 	
	Called when a func{MemoryPool} changes the buffer set up. 
	This allows to work directly on the buffers
	of a memory pool, e.~g.~ to initialize all buffers for DMA when
	memory pool is created.  
	  

\end{compactdesc}
      
      
\item  The virtual \func{ExecuteCommand()} method of \class{dabc::Device} 
      subclass may implement the callbacks of the defined commands.


\end{compactenum}

\section{Factories}
The set up of the application specific objects is done 
   by \class{dabc::Factory} subclasses.
\begin{compactenum}

\item  The user must define a \class{dabc::Factory} subclass to add own classes to the system. 

\item  Each factory is instantiated as static singleton when 
      loading the library that defines it. 

\item  Factories are registered and kept in the global manager. 
      The access to the factories' functionality is done via methods of the
      manager that scans all known factories to produce the requested object
      class. 

\item  The framework provides several factories for predefined 
      implementations (e.~g.~ \class{bnet::SenderModule}, \class{verbs::Device})
            
      
\item The user factory may implement such methods:
\begin{compactdesc}
	\item [\func{Module* CreateModule(const char* classname, const char* modulename, Command* cmd)}] : 
	Instantiate a \class{dabc::Module} of class \func{classname}. The object
	name of the module is taken from \func{modulename} argument. Optional 
	argument \func{Command* cmd} may pass further creation parameters 
	from the application to the new module, encapsulated in a command object.
	
\item [\func{Device* CreateDevice(const char* classname, const char* devname, Command* cmd)}] : 
	Instantiate a \class{dabc::Device} of class \func{classname}. The object
	name of the device is taken from \func{devname} argument. Optional 
	argument \func{Command* cmd} may pass further creation parameters 
	from the application to the new device, encapsulated in a command object.
	
\item [\func{Application* CreateApplication(const char* classname, Command* cmd)}] : 
	Instantiate a \class{dabc::Application} of class \func{classname}.  Optional 
	argument \func{Command* cmd} may pass further creation parameters 
	from the set-up to the new application, encapsulated in a command object.

            
\end{compactdesc}      

Note that the factory  methods for \class{dabc::Transport} objects
belong to the corresponding \class{dabc::Device} implementation (see section \ref{prog_plugin_device})). 
      


\end{compactenum}

\section{The DABC Application}
\label{prog_plugin_applicaton}
The specific application controlling code is defined in 
   the \class{dabc::Application}.   
\begin{compactenum}
\item  The manager has exactly one application object. 
      The user must implement a \class{dabc::Application} subclass.
\item  On startup time, the \class{dabc::Application} is instantiated
by means of a factory method 
      \func{CreateApplication(const char* classname, dabc::Command* cmd)}.
The text argument \func{classname} specifies which
application subclass is created; this name is taken from a setup parameter, i.~e.~ it may be read from an XML setup file. The framework will search all
registered factories for the method which can fullfill to create an application
of that name. So the user must provide a \class{dabc::Factory} that defines such method for his/her application implementation.
      
\item  The application  may register parameters that 
      define the application's configuration. These parameters can be set at 
      runtime from the configuration and controls system.
     
\item  The user may implement virtual methods \func{UserConfigure()} ,  
      \func{UserEnable()}, \func{UserBeforeStart()}, 
      \func{UserAfterStop()}, \func{UserHalt()} in his/her 
      \class{dabc::Application} subclass. These methods are executed by the 
      framework state machine before or after the corresponding state 
      transitions to do additional application specific configuration, 
      run control, and clean-up actions. Note: all generic state machine 
      actions (e.g. cleanup of modules and devices, starting 
      and stopping the working processors) are already handled by 
      the framework at the right time and need not to be invoked explicitely here.

\item   For special DAQ topologies (e.g. Bnet), the framework offers 
      implementations of the \class{dabc::Application} containing the 
      generic functionality (e.~g.~ \class{bnet::WorkerApplication}, \class{bnet::ClusterApplication}). 
      In this case, the user specific parts are implemented by subclassing 
      these and implementing additional virtual methods (e.~g.~ \func{CreateReadout()}).    
\end{compactenum}







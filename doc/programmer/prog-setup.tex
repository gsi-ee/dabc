[programmer/prog-setup.tex]
\label{prog_setup}
\section{Parameter class}

Configuration and status information of objects can be represented by \class{Parameter} class.
Any objects, derived from \class{WorkingProcessor} class, can has a list of parameters,
assigned to it - for instance, \class{Application}, \class{Device}, \class{Module}, \class{Port} classes.   
  
There are number of class \class{WorkingProcessor} methods to create parameter objects of different kinds 
and access their values. Full list one can see in following table:

\begin{tabular}{|l|l|lll|}
   \hline
Type & Class  & Create & Getter & Setter \\
   \hline
string &  StrParameter    & CreateParStr    & GetParStr     & SetParStr     \\
double &  DoubleParameter & CreateParDouble & GetParDouble  & SetParDouble  \\
int    &  IntParameter    & CreateParInt    & GetParInt     & SetParInt     \\
bool   &  StrParameter    & CreateParBool   & GetParBool    & SetParBool    \\
   \hline
\end{tabular}

As one can see, to store boolean parameter, string is used. If value of string is "true" (in lower case),
boolean value of such parameter recognized as true, otherwise false.

For any type of parameter GetParStr/SetParStr methods can be used. 

It is recommended to use class \class{WorkingProcessor} methods to create parameters and access its values,
but one also can use FindPar() method to find parameter object and use its methods directly.   


\section{Use parameter for control}

The main advantage to use parameter objects is that parameter values can be 
observed and changed using controlling system.

At any time, when parameter value changed by program via SetPar... methods, 
control system informed and represents such change in appropriate GUI element.
At the same time, if user modifies parameter value in the GUI, value of parameter object
will be changed and correspondent parent object (module, device) get callback via 
virtual method ParameterChanged(). Implementing correct reaction on this call, 
one can provide possibility to reconfigure/adjust running code on the fly.

Parameter value may be fixed via Parameter::SetFixed() method. This blocks possibility 
to change parameter value from both program and user side. Only when fixed flag set again to false,
parameter value can be changed. 

Not all parameters objects should be visible to control system. There is so-called 
visibility level of parameter, which is assigned to parameter when its instance is created.
Only if visibility level smaller than current level (configured in Manager::ParsVisibility()),
parameter will be "seen" by control system. Such level is configured  
via WorkingProcessor::SetParDflts() function before parameters objects are created.


\section{Example of parameters usage}

Lets consider example of module, which uses parameters:

\begin{verbatim}
class UserModule : public dabc::ModuleAsync {
   public:
      UserModule(const char* name, dabc::Command* cmd = 0) : 
         dabc::ModuleAsync(name, cmd)
      {
         CreateParBool("Output", true);
         CreateParInt("Counter", 0);
         CreateTimer("Timer", 1.0, false);
      }
      
      virtual void ProcessTimerEvent(dabc::Timer*)
      {
         SetParInt("Counter", GetParInt("Counter")+1);
         if (GetParBool("Output")) 
            DOUT1(("Counter = %d", GetParInt("Counter")));
      }
}; 
\end{verbatim}

In module constructor two parameters are created - boolean and integer and timer with period of 1 s.
When module started, value of integer parameter will be changed every second.
If boolean parameter is set to true, value of counter will be displayed on debug output.

Using control system, value of boolean parameter can be changed. To detect and react on such change,
one should implement following method: 
 
\begin{verbatim}
      virtual void ParameterChanged(dabc::Parameter* par) 
      {
         if (par->IsName("Output")) 
            DOUT1(("Output flag changed to %s", DBOOL(GetParBool("Output")));
      }
\end{verbatim}

From the performance reasons one should avoid usage of parameter getter/setter methods (like  
GetParBool() or SetParInt()) inside loop, which executed many times. Main aim of parameter
object is to provide connection to control system and in other situations normal class members should be used.


\section{Configuration parameters}

Another use of parameter object is its usage for objects configuration.
When one creates object like module or device, one often need to deliver 
one or several configurations parameters to constructor such as required
number of input ports or server socket port number. 

For such situation configuration parameter are defined.
This parameter should be created and set only in object constructor with following methods:
\bdes
\item[GetCfgStr]  string
\item[GetCfgDouble]   double 
\item[GetCfgInt]   integer
\item[GetCfgBool]   boolean 
\edes

All these methods has following arguments: name of configuration parameter, 
default value of configuration parameter [optional] and pointer on \class{Command} object [optional].
Lets add one configuration parameter to our module constructor:

\begin{verbatim}
      UserModule(const char* name, dabc::Command* cmd = 0) : 
         dabc::ModuleAsync(name, cmd)
      {
         CreateParBool("Output", true);
         CreateParInt("Counter", 0);
         double period = GetCfgDouble("Period", 1.0, cmd);
         CreateTimer("Timer", period, false);
      }
\end{verbatim}

Here period of timer is set via configuration parameter "Period". How its value will be defined? 

First of all, will be checked if parameter with given name exists in the command.
If not, appropriate entry in configuration file will be searched. If configuration file also
does not contains such parameter, default value will be used.


\section{Configuration file example}

Configuration file is xml file in dabc-specific format, which contains 
value of some or all configuration parameters of the system. 

Lets consider simple but functional example of configuration file:

\begin{verbatim}

<?xml version="1.0"?>
<dabc version="1">
  <Context host="localhost" name="Generator">
    <Run>
      <lib value="libDabcMbs.so"/>
      <func value="StartMbsGenerator"/>
    </Run>
    <Module name="Generator">
       <Port name="Output">
          <OutputQueueSize value="5"/>
          <MbsServerPort value="6000"/>
       </Port>
    </Module>
  </Context>
</dabc>

\end{verbatim}

This is an example of xml file for mbs generator, which produces 
mbs events and provides them to mbs transport server. 
To run that example, just "run.sh test.xml" should be executed in the shell.
Other application
(dabc or Go4) can connect to that server and read generated mbs events.


\section{Basic syntax}

DABC configuration file should always contain <dabc> as root node. 
Inside <dabc> node one or several <Context> nodes should exists.
Each <Context> node represents independent application context, which runs as
independent executable. 
Optionally <dabc> node can has <Variables> and <Defaults> nodes, which are described further. 


\section{Context}

<Context> node can has two optional attributes:
\bdes
\item["host"] host name, where executable should runs, default is localhost
\item["name"] application (manager), default is host name.
\edes

Inside <Context> node configuration parameters for modules, devices, memory pools are stored.
In example file one sees several parameters for output port of generator module.  


\section{Run arguments}

Usually <Context> node has <Run> subnode, where user defines different parameters, 
relevant for running dabc application:

\bdes
\item[lib] library name, which should be loaded. Several libraries names can be specified.
\item[func] function name which should be called to create modules. 
It is alternative to writing subclass of \class{Application} and instantiating it.
\item[port] ssh port number of remote host
\item[user] account name to be used for ssh (login without password should be possible)
\item[init] init script, which should be called before dabc application starts
\item[test] test script, which is called when test sequence is run by run.sh script
\item[timeout] ssh timeout 
\item[debugger] argument to run debugger. Value should be like "gdb -x run.txt --args", where file run.txt should contain commands "r bt q".
\item[workdir] directory where dabc application should start
\item[debuglevel] level of debug output on console, default 1
\item[logfile] filename for log output, default none  
\item[loglevel] level of log output to file, default 2 
\item[DIM\_DNS\_NODE] node name of dim dns server, used by dim control 
\item[DIM\_DNS\_PORT] port number of dim dns server, used by dim control 
\edes


\section{Variables}

In root <dabc> node one can insert <Variables> node, which may contain 
definition of one or several variables. Once defined, 
such variables can be used in any place of configuration file to set parameters values.
In this case syntax to set parameter is:

\begin{verbatim}
    <ParameterName value="${VariableName}"/>
\end{verbatim}

It is allowed to combine variable with text or other variable, 
but neither arithmetic nor string operations are supported. 

Using variables, one can modify example in following way:

\begin{verbatim}

<?xml version="1.0"?>
<dabc version="1">
  <Variables>
    <myname value="Generator"/> 
    <myport value="6010"/> 
  </Variables>
  <Context name="Mgr${myname}">
    <Run>
      <lib value="libDabcMbs.so"/>
      <func value="StartMbsGenerator"/>
    </Run>
    <Module name="${myname}">
       <SubeventSize value="32"/>
       <Port name="Output">
          <OutputQueueSize value="5"/>
          <MbsServerPort value="${myport}"/>
       </Port>
    </Module>
  </Context>
</dabc>

\end{verbatim}

Here context name and module name are set via myname variable and mbs server 
socket port is set via myport variable.

There are several variables, which are defined by configuration system:

\bbul
\item DABCSYS - top directory of dabc installation
\item DABCUSERDIR - user-specified directory
\item DABCWORKDIR - current working directory
\item DABCNUMNODES - number of <Context> nodes in configuration files
\item DABCNODEID - sequence number of current <Context> node in configuration file 
\ebul

Any environment variable can also be used as variable to set parameter values. 


\section{Default values}

There are situations, when one need to set same value to several similar parameters,
for instance same output queue length for all output ports in the module. One possible way
is to use variables (as described before) and set parameter value via variable. 
Disadvantage of such approach that one should expand xml files and in case 
of big number of ports xml file will be very long and unreadable.

Another possibility to set several parameters at once - create <dabc/Defaults> node and
specify cast rule, using "*" or "?" symbols like that: 

\begin{verbatim}

<?xml version="1.0"?>
<dabc version="1">
  <Variables>
    <myname value="Generator"/> 
    <myport value="6010"/> 
  </Variables>

  <Context name="Mgr${myname}">
    <Run>
      <lib value="libDabcMbs.so"/>
      <func value="StartMbsGenerator"/>
    </Run>
    <Module name="${myname}">
       <SubeventSize value="32"/>
       <Port name="Output">
          <MbsServerPort value="${myport}"/>
       </Port>
    </Module>
  </Context>
  <Defualts>
    <Module name="*">
       <Port name="Output*">
          <OutputQueueSize value="5"/>
       </Port>
    </Module>
  </Defualts>
</dabc>

\end{verbatim}

In this case for all ports, which names are started with string "Output" from any module,
output queue length will be 5. 

In form, as it is specified in example, such multicast rule will be applied for 
all contexts from configuration file means by such rule we set output queue length 
for all modules on all nodes. This allow us to create compact xml files for big multi-nodes configuration.   


\section{Usage commands for configuration}

Lets consider possibility to configure module, using \class{Command} class.

This is required when object (like mnodule) should be created with fixed parameters
disregard of values specified in config file.

In our example one can modify StartMbsGenerator() function in following way:

\begin{verbatim}

extern "C" void StartMbsGenerator() 
{
    dabc::Command* cmd = new dabc::CmdCreateModule("mbs::GeneratorModule", "Generator");
    cmd->SetInt("SubeventSize", 128);
    if (!dabc::mgr()->Execute(cmd)) {
       EOUT(("Cannot create generator module"));
       exit(1);
    }
    
    ...
}
\end{verbatim}

Here one add additional arguments to \comm{CmdCreateModule}, 
which set mbs subevent size to 128. After that any modification of
<SubeventSize> entry in config file take no effects.

